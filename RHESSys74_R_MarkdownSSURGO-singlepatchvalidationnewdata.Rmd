---
title: "RHESSysIOinR_Coweeta_WS32_74 Multi Site Validation Field Data"
author: "Carlos Quintero"
date: "5/24/2024"
output:
  html_document: default
  pdf_document: default
---

Coweeta Hydrologic Laboratory Watershed 32 using Static, SSURGO, and RSS soil inputs. Previously WS27.

The following R Markdown script prepares and runs the Regional Hydro-Ecologic Simulation System (RHESSYS) within the R environment. 
Modified from RHESSysIOinR example scripts created by Will Burke and Ryan Bart. Includes CLHS code snippets and SDA code from Dylan Beaudette.

Windows Subsystem via Linux must be installed before RHESSys will run in a Windows environment.
GRASS8 must be installed to run the spatial preprocessing portion of the script.

Code has been modified to run RHESSys 7.4 and 5.18. 
7.4 vegetation processing differs slightly from 5.18.
Various template differences exist between the two versions of RHESSys and template files must be carefully reviewed if moving between versions.
This script is currently set up to run RHESSys 7.4

```{r setup, include=TRUE, verbose = FALSE}
#install.packages("devtools")
#devtools::install_github("ropensci/FedData")

library(aqp)
library(daymetr)
library(clhs)
library(EcoHydRology)
library(elevatr)
library(ezknitr)
library(FedData)
library(foreach)
library(foreign)
library(ggplot2)
library(ggpubr)
library(hydroGOF)
library(imputeTS)
library(knitr)
library(latticeExtra)
library(lubridate)
library(Metrics)
library(raster)
library(rasterVis)
library(readxl)
library(reshape2)
library(rgdal)
library(rgrass)
library(Rmisc)
library(RHESSysPreprocessing)
library(RHESSysIOinR)
library(sf)
library(soilDB)
library(sp)
library(stats)
library(stringi)
library(tactile)
library(terra)
library(testthat)
library(tidyverse)
library(viridisLite)
library(dplyr)

knitr::opts_knit$set(root.dir = system.file("extdata/", package = "RHESSysIOinR"))

## Prep RHESSys
expect_file_exists = function(path) {
  # 1. Capture object and label
  act <- quasi_label(rlang::enquo(path), arg = "path")
  # 2. Call expect()
  expect(
    file.exists(act$val),
    sprintf("%s file does not exist.", act$lab)
  )
  # 3. Invisibly return the value
  invisible(act$val)
}

expect_file_sizeKB_gt = function(path, size_KB) {
  # 1. Capture object and label
  act <- quasi_label(rlang::enquo(path), arg = "path")
  # 2. Call expect()
  expect(
    (file.size(act$val) / 1024) > size_KB,
    sprintf("%s file is not greater than %f KB.", act$lab, size_KB)
  )
  # 3. Invisibly return the value
  invisible(act$val)
}

setwd(system.file("extdata/", package = "RHESSysIOinR"))

### Downloads most recent version of RHESSYs
# gert::git_clone(url = "https://github.com/RHESSys/RHESSys", path = "./rh_dev", branch = "master")

### Make sure to change files in rh_dev to 5.18 if using older RHESSys files
# compile_rhessys(location = "rh_dev/")

rh_ver = dir(path = "rh_dev/rhessys/", pattern = "^rhessys\\d+",recursive = F)

test_that("compile_rhessys works + rhessys compiles via R system", {
  expect_gt(length(rh_ver), 0)
})

rh_path = file.path("rh_dev/rhessys/", rh_ver)

```

Load in Shapefiles for Watershed Setup

```{r Locate Necessary Files}

getwd()
setwd(system.file("extdata/", package = "RHESSysIOinR"))

watershedshapefile <-("C:/Users/Carlos/Desktop/RHESSys_R_Processing/Boundary Shapefiles/Coweeta_Hydrologic_Laboratory.shp")
streamshapefile<- ("C:/Users/Carlos/Desktop/ORISE/GIS/CW/Streamflow/StreamsCaldwellClipped.shp")
weirshapefile<- ("C:/Users/Carlos/Desktop/ORISE/GIS/CW/Weirs/Subbasinoutlets.shp")
roadshapefile <- ( "C:/Users/Carlos/Desktop/ORISE/GIS/CW/Roads/UpdatedRoads4Reprojected32617.shp")

CWRG12 <- ("C:/Users/Carlos/Desktop/ORISE/Climate Data/CW/Precipitation/RDS-2017-0031/Data/RG12_daily_1942_2021.csv")
CWRG20 <-("C:/Users/Carlos/Desktop/ORISE/Climate Data/CW/Precipitation/RDS-2017-0031/Data/RG20_daily_1962_2021.csv")

CS01 <- ("C:/Users/Carlos/Desktop/ORISE/Climate Data/CW/Air Temperature/CS01 OISHI/cs01_hourly_Tair_2011_2023.csv")
CS01LT<- ("C:/Users/Carlos/Desktop/ORISE/Climate Data/CW/Air Temperature/RDS-2015-0049/Data/cs01_daily_airtemp.csv")

CS21<- ("C:/Users/Carlos/Desktop/ORISE/Climate Data/CW/Air Temperature/RDS-2015-0042/Data/cs21_daily.csv")
CS28<- ("C:/Users/Carlos/Desktop/ORISE/Climate Data/CW/Air Temperature/RDS-2015-0042/Data/cs28_daily.csv")

newsmlocations<- ("C:/Users/Carlos/Desktop/ORISE/Soil Moisture Data/NRCS Soil Moisture Sites/Soil Moisture Sites/CoweetaNRCSsmKML.kml")

```

Create Local Base File
```{r}
{basefiletext<- "101  base_station_id
275535 x_coordinate
3879165 y_coordinate
1064 z_coordinate
3.5  effective_lai
5.0 screen_height
clim/cwt_annual	annual_climate_prefix
0			number_non_critical_annual_sequences
clim/cwt_monthly 	monthly_climate_prefix
0			number_non_critical_monthly_sequences
clim/cwtws32local daily_climate_prefix
0			number_non_critical_daily_sequences
clim/cwt_hourly 	hourly_climate_prefix
0			number_non_critical_hourly_sequences
clim/cwt	trigger_of_dated_input
0	num_non_critical_sequences
"}

write(basefiletext,file = "clim/cwtws32local.base")

```

Download or find Local Climate for Watershed of Interest
Precip and Temperature

https://www.fs.usda.gov/rds/archive/Catalog/RDS-2017-0031


RGO6-WS32 & RG12-WS32 - Using RG12
RG20-WS7
Precipitation is in inches

CS21-WS7
CS28-WS32
Temperature is in Celsius

RHESSys can use
Rain (Meters),Tmin (C),Tmax (C),Tavg (C),RHmin (0-1),RHmax (0-1),RHavg (0-1),Wind (Meters/Sec),Wind Dir (Degrees)

only using Rain, Tmin and Tmax for now

"One of the most intense arctic outbreaks of the 20th century occurred January 18-22, 1985.  Extremely cold temperatures affected every state east of the Rockies with three new state record lows established: -34° at Mt. Mitchell, North Carolina, -19° at Caesar's Head, South Carolina; and -30° at Mountain Lake, Virginia. " Taken from weather.gov

lowest temp -34, all TMIN values less than -34 will be removed as erroneous values

```{r}
cwtrg12precip<- read.table(file=CWRG12, header = TRUE, sep = ",")
cwtrg20precip<- read.table(file=CWRG20, header = TRUE, sep = ",")

cwtrg12precip$date <- as.Date(paste(cwtrg12precip$YEAR,cwtrg12precip$MONTH,cwtrg12precip$DAY, sep = "-"), "%Y-%m-%d")
cwtrg20precip$date <- as.Date(paste(cwtrg20precip$YEAR,cwtrg20precip$MONTH,cwtrg20precip$DAY, sep = "-"), "%Y-%m-%d")

plot(cwtrg12precip$date,cwtrg12precip$RRG12, type = "h", main = "Coweeta Rain Gauge 12 Precipitation", col = "BLUE")
plot(cwtrg20precip$date,cwtrg20precip$RRG20, type = "h", main = "Coweeta Rain Gauge 20 Precipitation", col = 4)

# cwttemp<- read.table(file=CS01, header = TRUE, sep = ",")
# cwtlongtemp<- read.table(file=CS01LT, header = TRUE, sep = ",")

cwtcs21<-  read.table(file=CS21, header = TRUE, sep = ",")
cwtcs28<- read.table(file=CS28, header = TRUE, sep = ",")

# cwttemp$date <- as.Date(paste(cwttemp$YEAR,cwttemp$MONTH,cwttemp$DAY, sep = "-"), "%Y-%m-%d")
# cwtlongtemp$date <- as.Date(paste(cwtlongtemp$YEAR,cwtlongtemp$MONTH,cwtlongtemp$DAY, sep = "-"), "%Y-%m-%d")

cwtcs21$date<- as.Date(paste(cwtcs21$YEAR,cwtcs21$MONTH,cwtcs21$DAY, sep = "-"), "%Y-%m-%d")
cwtcs28$date<- as.Date(paste(cwtcs28$YEAR,cwtcs28$MONTH,cwtcs28$DAY, sep = "-"), "%Y-%m-%d")

# cwttemp<- as_tibble(cwttemp)
# cwtlongtemp<- as_tibble(cwtlongtemp)

cwtcs21 <- as_tibble(cwtcs21)
cwtcs28 <- as_tibble(cwtcs28)

##filtering low temp in climate station files
cwtcs21<- cwtcs21 %>% mutate(TMIN= ifelse(TMIN < -34, NA,TMIN))
cwtcs28<- cwtcs28 %>% mutate(TMIN= ifelse(TMIN < -34, NA,TMIN))

# daily_avgCS01 <- cwttemp %>%
#   group_by(date) %>%
#   dplyr::summarise(TAVG_daily=mean(TAVG, na.rm = TRUE),RHAVG_daily=mean(RHAVG,na.rm = TRUE))
# 
# daily_avgCS01LT <- cwtlongtemp %>%
#   group_by(date)
  
# plot(daily_avgCS01$date,daily_avgCS01$TAVG_daily, type = "l", col = 1, main = "Daily Temperature Average")
# plot(daily_avgCS01$date,daily_avgCS01$RHAVG_daily, type = "l", col = 2, main = "Daily RH Average")

#Combine Rain Gauge and Climate Station datasets
cwtrg12precip<- as_tibble(cwtrg12precip)
cwtrg20precip<- as_tibble(cwtrg20precip)

###make sure to create full date time series before left join
full_dates<- tibble(date = seq.Date(from = min(cwtrg12precip$date), to = max(cwtrg12precip$date), by = "day"))

full_dates

combinedcwtclimate<- full_dates %>% left_join(cwtrg12precip, by = c("date"))

cwtrg20_selected <- cwtrg20precip %>% select(date, RRG20)

combinedcwtclimate <- combinedcwtclimate %>% left_join(cwtrg20_selected, by = c("date"))

#convert precip from inces to meters
combinedcwtclimate$RRG12 <- combinedcwtclimate$RRG12* 0.0254
combinedcwtclimate$RRG20 <- combinedcwtclimate$RRG20* 0.0254



##precip converted from inches to meters
## RH converted to 0-1 range


cwtcs21_selected <- cwtcs21 %>% mutate(RHMIN = RHMIN/100, RHMAX = RHMAX/100, RHAVG = RHAVG/100) %>% select(date, TMINcs21=TMIN, TMAXcs21=TMAX, TAVGcs21=TAVG, RHMINcs21=RHMIN, RHMAXcs21=RHMAX, RHcs21=RHAVG, WINDcs21=WIND, WDIRcs21=W_DIR)
cwtcs28_selected <- cwtcs28 %>% mutate(RHMIN = RHMIN/100, RHMAX = RHMAX/100, RHAVG = RHAVG/100) %>% select(date, TMINcs28=TMIN, TMAXcs28=TMAX, TAVGcs28=TAVG, RHMINcs28=RHMIN, RHMAXcs28=RHMAX, RHcs28=RHAVG, WINDcs28=WIND, WDIRcs28=W_DIR)

combinedcwtclimate <- combinedcwtclimate %>% left_join(cwtcs21_selected, by = c("date"))
combinedcwtclimate <- combinedcwtclimate %>% left_join(cwtcs28_selected, by = c("date"))

combinedcwtclimate

first_valid_index<- combinedcwtclimate %>%  dplyr::mutate(row_num = row_number()) %>% filter(!is.na(RRG12)& !is.na(RRG20)& !is.na(TMINcs21)& !is.na(TMINcs28) ) %>% slice(1) %>% pull(row_num)

last_valid_index<- combinedcwtclimate %>%  dplyr::mutate(row_num = row_number()) %>% filter(!is.na(RRG12)& !is.na(RRG20)& !is.na(TMINcs21)& !is.na(TMINcs28) ) %>% slice(n()) %>% pull(row_num)

first_valid_index

trimmed_cwtclimate <- combinedcwtclimate %>% slice(first_valid_index:last_valid_index)

trimmed_cwtclimate

trimmedstartdaterhessys<- paste(year(ymd(trimmed_cwtclimate$date[1])), month(ymd(trimmed_cwtclimate$date[1])), day(ymd(trimmed_cwtclimate$date[1])),"1")
  
trimmedstartdaterhessys

trimmed_cwtclimate <- trimmed_cwtclimate %>% select(-YEAR,-MONTH,-DAY)

# Replace NA values according to the specified rules
##NA APPROX is used, zoo package, interpolation


trimmed_cwtclimate <- trimmed_cwtclimate %>%
  mutate(
    RRG12 = ifelse(is.na(RRG12), 0, RRG12),
    RRG20 = ifelse(is.na(RRG20), 0, RRG20),
    TMINcs21 = ifelse(is.na(TMINcs21),TAVGcs21,TMINcs21),
    TMINcs28 = ifelse(is.na(TMINcs28),TAVGcs28,TMINcs28),
    TMINcs21 = na.approx(TMINcs21),
    TMAXcs21 = na.approx(TMAXcs21),
    TMINcs28 = na.approx(TMINcs28),
    TMAXcs28 = na.approx(TMAXcs28),
    TAVGcs21 = na.approx(TAVGcs21),
    TAVGcs28 = na.approx(TAVGcs28),
    TAVGcs21 = ifelse(TAVGcs21>TMINcs21 & TAVGcs21<TMAXcs21,TAVGcs21,(TMAXcs21+TMINcs21/2)),
    TAVGcs28 = ifelse(TAVGcs28>TMINcs28 & TAVGcs28<TMAXcs28,TAVGcs28,(TMAXcs28+TMINcs28/2)),
    RHMINcs21= na.approx(RHMINcs21),
    RHMINcs28= na.approx(RHMINcs28),
    RHMAXcs21= na.approx(RHMAXcs21),
    RHMAXcs28= na.approx(RHMAXcs28),
    RHcs21 = na.approx(RHcs21),
    RHcs28 = na.approx(RHcs28),
    WINDcs21 = na.approx(WINDcs21),
    WINDcs28 = na.approx(WINDcs28),
    WDIRcs21 = na.approx(WDIRcs21),
    WDIRcs28 = na.approx(WDIRcs28)
)


# View the resulting dataframe
print(trimmed_cwtclimate)

rows_with_na <- trimmed_cwtclimate %>%
  filter_all(any_vars(is.na(.)))

print(rows_with_na)

##make sure units are correct

cwtws32localrain<- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$RRG12)))
cwtws32localtmin<- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$TMINcs28)))
cwtws32localtmax<- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$TMAXcs28)))
cwtws32localtavg <- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$TAVGcs28)))
cwtws32localrhmin <- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$RHMINcs28)))
cwtws32localrhmax <- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$RHMAXcs28)))
cwtws32localrhavg <- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$RHcs28)))
cwtws32localwind <- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$WINDcs28)))
cwtws32localwdir <- data.frame(rbind(trimmedstartdaterhessys, as.data.frame(trimmed_cwtclimate$WDIRcs28)))


write.table(cwtws32localrain, file = "clim/cwtws32local.rain", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localtmin, file = "clim/cwtws32local.tmin", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localtmax, file = "clim/cwtws32local.tmax", quote = FALSE, row.names = FALSE, col.names = FALSE)

write.table(cwtws32localtavg, file = "clim/cwtws32local.tavg", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localrhmin, file = "clim/cwtws32local.relative_humidity_min", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localrhmax, file = "clim/cwtws32local.relative_humidity_max", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localrhavg, file = "clim/cwtws32local.relativehumidity", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localwind, file = "clim/cwtws32local.wind", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtws32localwdir, file = "clim/cwtws32local.wind_direction", quote = FALSE, row.names = FALSE, col.names = FALSE)



```
Extend Local Datasets
```{r}

precip <- read.csv('clim/cwtws32local.rain', header = FALSE)
tmin <- read.csv('clim/cwtws32local.tmin', header = FALSE)
tmax <- read.csv('clim/cwtws32local.tmax', header = FALSE)

head(precip)
nrow(precip)-1

substr(precip[1,1],1,nchar(precip[1,1])-2)

dt <- as.Date(substr(precip[1,1],1,nchar(precip[1,1])-2), "%Y %m %d")

dt.new<- dt - as.difftime((nrow(precip)-1)*8, units="days")

#remove first value and repeats dataset 9 times

longcwtraindata<- do.call("rbind",replicate(9,as.list((precip[-1,]))))
longcwttmindata<- do.call("rbind",replicate(9,as.list((tmin[-1,]))))
longcwttmaxdata<- do.call("rbind",replicate(9,as.list((tmax[-1,]))))

longcwstartdate<- paste(year(ymd(dt.new)),month(ymd(dt.new)),day(ymd(dt.new)),"1")

longcwtrain<- rbind(longcwstartdate,longcwtraindata)
longcwttmin<- rbind(longcwstartdate,longcwttmindata)
longcwttmax<- rbind(longcwstartdate,longcwttmaxdata)

longcwtrain<- data.frame(longcwtrain)
longcwttmin<- data.frame(longcwttmin)
longcwtmax<- data.frame(longcwttmax)

write.table(longcwtrain, file = "clim/cwtws32extended.rain", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(longcwttmin, file = "clim/cwtws32extended.tmin", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(longcwttmax, file = "clim/cwtws32extended.tmax", quote = FALSE, row.names = FALSE, col.names = FALSE)

read_clim("clim/cwtws32extended.rain", dates_out=TRUE)
read_clim("clim/cwtws32local.rain", dates_out=TRUE)

```
Create DAYMET Base File
```{r Create Daymet Base File}
##Quick way to create base file necessary for climate processing 

{daymetbasefiletext<- "101  base_station_id
275535 x_coordinate
3879165 y_coordinate
1064 z_coordinate
3.5  effective_lai
5.0 screen_height
clim/cwt_annual	annual_climate_prefix
0			number_non_critical_annual_sequences
clim/cwt_monthly 	monthly_climate_prefix
0			number_non_critical_monthly_sequences
clim/cwtws32daymet daily_climate_prefix
0			number_non_critical_daily_sequences
clim/cwt_hourly 	hourly_climate_prefix
0			number_non_critical_hourly_sequences
clim/cwt	trigger_of_dated_input
0	num_non_critical_sequences
"}

write(daymetbasefiletext,file = "clim/cwtws32daymet.base")

```

Download Daymet Data for Watershed of Interest using daymetr package
Currently only creates precip, tmin and tmax files.

```{r Create Daymet Datasets, eval=FALSE, include=FALSE}

## only using climate inputs provided by DAYMET
#.rain,.tmin,.tmax required
# .dayl, .surface_shortwave_rad, 

getwd()

setwd(system.file("extdata/", package = "RHESSysIOinR"))

daymet_data <- download_daymet("Coweeta_WS32",
                               lat = 35.04867,
                               lon = -83.4601,
                               start = 1980,
                               end = 2021,
                               internal = TRUE)

daymetstartdate<- as.Date(paste(daymet_data$data$year,daymet_data$data$yday, sep = "-"), "%Y-%j")[1]

daymetstartdaterhessys<- paste(year(ymd(daymetstartdate)),month(ymd(daymetstartdate)),day(ymd(daymetstartdate)),"1")


daymetstartdate

daymetenddate<- as.Date(paste(daymet_data$data$year,daymet_data$data$yday, sep = "-"), "%Y-%j")[length(daymet_data$data$year)]

daymetenddate


## calculate dates for daymet data from year and yday data

daymet_data$data$date <- as.Date(paste(daymet_data$data$year,daymet_data$data$yday, sep = "-"), "%Y-%j")

##create time series and append values


date_vector <- seq.Date(daymetstartdate, daymetenddate, by = "day")

length(date_vector)

length(daymet_data$data$prcp..mm.day.)

date_precip<- as.data.frame(c(date_vector))

names(date_precip) <- "Dates"

date_precip


fulldaymetprecip<- merge(date_precip,daymet_data$data, by.x="Dates", by.y="date", all.x=TRUE)

dim(date_precip)

dim(fulldaymetprecip)

dim(daymet_data$data)

fulldaymetprecip

## for simplicity replace NA values with 0, may cause issues with temp but should be ok for precip

fulldaymetprecip<- na_replace(fulldaymetprecip,0)


#convert precipitation to Meters
cwtdaymetrain<- rbind(daymetstartdaterhessys,as.data.frame(fulldaymetprecip$prcp..mm.day./1000))
cwtdaymettmin<- rbind(daymetstartdaterhessys,as.data.frame(fulldaymetprecip$tmin..deg.c.))
cwtdaymettmax<- rbind(daymetstartdaterhessys,as.data.frame(fulldaymetprecip$tmax..deg.c.))

cwtdaymetrain<- data.frame(cwtdaymetrain)
cwtdaymettmin<- data.frame(cwtdaymettmin)
cwtdaymettmax<- data.frame(cwtdaymettmax)

write.table(cwtdaymetrain, file = "clim/cwtws32daymet.rain", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtdaymettmin, file = "clim/cwtws32daymet.tmin", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(cwtdaymettmax, file = "clim/cwtws32daymet.tmax", quote = FALSE, row.names = FALSE, col.names = FALSE)

```

Extend DAYMET datasets to allow for longer spinup period
Read Daymet Datasets and Replicate 5x times to create a longer period of record for spin up
Create base File manually for now

```{r Extend Daymet Datasets}
## this may be the source of lag in outputs/measured data
getwd()

precip <- read.csv('clim/cwtws32daymet.rain', header = FALSE)
tmin <- read.csv('clim/cwtws32daymet.tmin', header = FALSE)
tmax <- read.csv('clim/cwtws32daymet.tmax', header = FALSE)
#tavg <- read.csv('clim/cwtws32daymet.tavg', header = FALSE)
#rh <- read.csv('clim/cwtws32daymet.relative_humidity', header = FALSE)
#wind <- read.csv('clim/cwtws32daymet.wind', header = FALSE)

head(precip)
nrow(precip)-1

substr(precip[1,1],1,nchar(precip[1,1])-2)

dt <- as.Date(substr(precip[1,1],1,nchar(precip[1,1])-2), "%Y %m %d")

dt.new<- dt - as.difftime((nrow(precip)-1)*5, units="days")

#remove first value and repeats dataset 6 times

longcwtraindata<- do.call("rbind",replicate(6,as.list((precip[-1,]))))
longcwttmindata<- do.call("rbind",replicate(6,as.list((tmin[-1,]))))
longcwttmaxdata<- do.call("rbind",replicate(6,as.list((tmax[-1,]))))
#longcwttavgdata<- do.call("rbind",replicate(6,as.list((tavg[-1,]))))
#longcwtrhdata<- do.call("rbind",replicate(6,as.list((rh[-1,]))))
#longcwtwinddata<- do.call("rbind",replicate(6,as.list((wind[-1,]))))

longcwstartdate<- paste(year(ymd(dt.new)),month(ymd(dt.new)),day(ymd(dt.new)),"1")

longcwtrain<- rbind(longcwstartdate,longcwtraindata)
longcwttmin<- rbind(longcwstartdate,longcwttmindata)
longcwttmax<- rbind(longcwstartdate,longcwttmaxdata)
#longcwttavg<- rbind(longcwstartdate,longcwttavgdata)
#longcwtrh<- rbind(longcwstartdate,longcwtrhdata)
#longcwtwind<- rbind(longcwstartdate,longcwtwinddata)

longcwtrain<- data.frame(longcwtrain)
longcwttmin<- data.frame(longcwttmin)
longcwtmax<- data.frame(longcwttmax)
#longcwttavg<- data.frame(longcwttavg)
#longcwtrh<- data.frame(longcwtrh)
#longcwtwind<- data.frame(longcwtwind)

write.table(longcwtrain, file = "clim/cwtws32daymetextended.rain", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(longcwttmin, file = "clim/cwtws32daymetextended.tmin", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(longcwttmax, file = "clim/cwtws32daymetextended.tmax", quote = FALSE, row.names = FALSE, col.names = FALSE)
#write.table(longcwttavg, file = "clim/cwtws32extended.tavg", quote = FALSE, row.names = FALSE, col.names = FALSE)
#write.table(longcwtrh, file = "clim/cwtws32extended.relative_humidity", quote = FALSE, row.names = FALSE, col.names = FALSE)
#write.table(longcwtwind, file = "clim/cwtws32extended.wind", quote = FALSE, row.names = FALSE, col.names = FALSE)

read_clim("clim/cwtws32extended.rain", dates_out=TRUE)
read_clim("clim/cwtws32daymet.rain", dates_out=TRUE)

```

Download and Prepare DEM 
Code to download DEM originally prepared by Dylan Beaudette

```{r Download and Prepare DEM}
# use watershed polygons for BBOX to request elevation data
x <- read_sf(watershedshapefile)
# buffer to ensure that there are no truncated watersheds
x.buff <- st_as_sf(st_buffer(st_as_sfc(st_bbox(x)), dist = 1000))
# convert to GCS WGS84 -> no transformation / warp will be applied to DEM
x.gcs <- st_transform(x, 4326)
x.buff.gcs <- st_transform(x.buff, 4326)
# requires sf collection (geometry + attributes)
# get DEM in GCS WGS84 and use z = 14 for best available data
e <- get_elev_raster(locations = x.buff.gcs, z = 14, clip = 'bbox')

res(e)

# check: OK
{plot(e, main = "DEM, Watershed Outline and Buffer" )
  plot(st_geometry(x.buff.gcs), add = TRUE, col = NA, lwd = 2)
  plot(st_geometry(x.gcs), add = TRUE, col = NA)}

{plot(e, main = "DEM and selected Watershed")
  plot(st_geometry(x.gcs[which(x$WS=='32'),]), add = TRUE, col = NA)}

cropped_dem<- crop(e,st_bbox(x.gcs))

plot(cropped_dem, main = "DEM cropped to Buffer")
plot(st_geometry(x.gcs[which(x$WS=='32'),]), add = TRUE, col = NA)



newproj<- "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"

reproje<- projectRaster(from = cropped_dem, crs = newproj, method = 'bilinear')

plot(reproje, main = "Reprojected cropped DEM")

dummydata<- reproje

res(dummydata) <- 10

resampleddem <- resample(reproje, dummydata, method = 'bilinear')

plot(resampleddem, main = "DEM reprojected to 10m Resolution")

{plot(resampleddem, main = "DEM reprojected to 10m Resolution")
  plot(st_geometry(x.buff.gcs), add = TRUE, col = NA, lwd = 2)
  plot(st_geometry(x.gcs), add = TRUE, col = NA)}

```

Start Spatial Processing in GRASS8
Code to prepare spatial input files for RHESSYs takes cues from Will Burkes "spatial_input_gen.R" script but is prepared for GRASS8 instead of GRASS7

```{r Prepare Spatial Input in GRASS8}
#gisbase_grass <- ifelse(.Platform$OS.type == "windows", link2GI::paramGRASSw()$gisbase_GRASS[1], link2GI::paramGRASSx()$gisbase_GRASS[1])

## set easting and northing as coordinates of lowest point within boundary basin, set threshold for basin delineation
threshold = 400
easting = NULL
northing = NULL
 

initGRASS(gisBase = "C:/Program Files/GRASS GIS 8.2",
          gisDbase = "C:/Users/Carlos/Documents/grassdata",
          location = "Coweeta", 
          mapset = "PERMANENT", 
          override = TRUE)

execGRASS("g.proj", proj4="+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs", flag = "c" )

execGRASS("g.gisenv", flag="n")

execGRASS("g.region", flag=c("p"))

##Convert DEM to Spatrast and then import DEM to GRASS 

spatrast_dem10 <- rast(resampleddem)

write_RAST(spatrast_dem10, "grass_dem10", overwrite = TRUE)

## The following code is heavily influenced by Will Burkes "spatial_input_gen.R" script

execGRASS("g.region", raster = "grass_dem10", flag=c("p"))

## Import shapefiles (Streams, Weirs, Watersheds, Roads)
## only roads and Watersheds necessary to Run

streams<- vect("C:/Users/Carlos/Desktop/ORISE/GIS/CW/Streamflow/StreamsCaldwellClipped.shp")
streams<- project(streams,"+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")
write_VECT(streams, "streams")

weirs<- vect("C:/Users/Carlos/Desktop/ORISE/GIS/CW/Weirs/Subbasinoutlets.shp")
weirs<- project(weirs,"+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")
write_VECT(weirs, "weirs")

watersheds<- vect("C:/Users/Carlos/Desktop/RHESSys_R_Processing/Boundary Shapefiles/Coweeta_Hydrologic_Laboratory.shp")
wgs84watersheds<- project(watersheds,"+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")
write_VECT(wgs84watersheds, "watersheds")

roads <- vect( "C:/Users/Carlos/Desktop/ORISE/GIS/CW/Roads/UpdatedRoads4Reprojected32617.shp")
roads<- project(roads,"+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")
write_VECT(roads,"roads")

## Check all vectors that have been exported to GRASS

execGRASS("g.list", parameters = list(type = "vector"))

## Generate a depressionless DEM and d-8 flow direction maps from DEM

execGRASS("r.fill.dir", input="grass_dem10", output="dem10f", direction="dir10", flags = c("overwrite") )

## Generate flow accumulation, drainage, and horizon maps

execGRASS("r.watershed", elevation = "dem10f", accumulation = "acc10", drainage = "drain10")

## Generate slope, aspect, wetness index, horizon, and road maps

execGRASS("r.slope.aspect", elevation = "grass_dem10", slope = "slope10", aspect = "aspect10")

execGRASS("r.topidx", input = "grass_dem10", output = "topidx10")

execGRASS("r.mapcalc", expression = "topidx10_100 = topidx10 * 100", flags = "overwrite")

execGRASS("r.horizon", flags = "d", elevation = "grass_dem10", direction = 0, output = "east")
execGRASS("r.horizon", flags = "d", elevation = "grass_dem10", direction = 180, output = "west")

execGRASS("r.mapcalc", expression = "e_horizon_1000 = sin(east_000) * 1000", flags = "overwrite")
execGRASS("r.mapcalc", expression = "w_horizon_1000 = sin(west_180) * 1000", flags = "overwrite")

## Generate a hillslope and stream map

subbasin_name = paste0("subbasin_th",as.character(threshold))
stream_name = paste0("stream_th",as.character(threshold))
hillslope_name = paste0("hillslope_th",as.character(threshold))

execGRASS("r.watershed", elevation = "dem10f", threshold = threshold, basin = subbasin_name, stream = stream_name, half_basin = hillslope_name)

## Delineate watershed boundary

weirs[12,]

easting = 276122.49
northing = 3881345.46

execGRASS("g.region", raster = "grass_dem10", flag=c("p"))

execGRASS("r.water.outlet", input ="drain10", output="basin_ws32",coordinates = c(easting, northing), flags = "overwrite")

## Mask Data
# execGRASS("r.mask", input = "basin_ws32", maskcats = 1)

execGRASS("r.info",map = "basin_ws32")

execGRASS("r.info",map = "grass_dem10")

## Generate Patch Maps

execGRASS("r.mapcalc", expression = "patch = row() * 537 + col()", flags = "overwrite")

## Create Road Maps

execGRASS("v.to.rast", input="roads" ,output="roads", use="cat", label_column="ROADNAME", flags = "overwrite")

execGRASS("r.mapcalc", expression = "roads = roads > 0", flags = "overwrite")

execGRASS("r.null", map = "roads", null= 0)

## Check all rasters that have been exported to or created in GRASS

execGRASS("g.list", parameters = list(type = "raster"))

## Export Prepared Maps from GRASS to R

filleddem <- read_RAST("dem10f")

##Export maps back into R or export directly from GRASS to disk

grass_acc10 <- read_RAST("acc10")
grass_aspect10 <- read_RAST("aspect10")
grass_basin_ws32 <- read_RAST("basin_ws32")
grass_dem10 <- read_RAST("grass_dem10")
grass_dem10f <- read_RAST("dem10f")
grass_dir10 <- read_RAST("dir10")
grass_drain10 <- read_RAST("drain10")
grass_e_horizon_1000 <- read_RAST("e_horizon_1000")
grass_hillslope_th1000 <- read_RAST("hillslope_th1000")
#grass_patch <- read_RAST("patch")
grass_slope10 <- read_RAST("slope10")
grass_stream_th1000 <- read_RAST("stream_th1000")
grass_topidx10 <- read_RAST("topidx10")
grass_topidx10_100 <- read_RAST("topidx10_100")
grass_w_horizon_1000 <- read_RAST("w_horizon_1000")
grass_east_000 <- read_RAST("east_000")
grass_west_180 <- read_RAST("west_180")
grass_subbasin_th1000 <- read_RAST("subbasin_th1000")


execGRASS("r.out.gdal", input = "acc10", output = "grassexport/cwt/acc10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "aspect10", output = "grassexport/cwt/aspect10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "basin_ws32", output = "grassexport/cwt/basin_ws32.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "grass_dem10", output = "grassexport/cwt/grass_dem10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "dem10f", output = "grassexport/cwt/dem10f.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "dir10", output = "grassexport/cwt/dir10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "drain10", output = "grassexport/cwt/drain10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "e_horizon_1000", output = "grassexport/cwt/e_horizon_1000.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "hillslope_th1000", output = "grassexport/cwt/hillslope_th1000.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "patch", output = "grassexport/cwt/patch.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "slope10", output = "grassexport/cwt/slope10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "stream_th1000", output = "grassexport/cwt/stream_th1000.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "topidx10", output = "grassexport/cwt/topidx10.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "topidx10_100", output = "grassexport/cwt/topidx10_100.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "w_horizon_1000", output = "grassexport/cwt/w_horizon_1000.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "east_000", output = "grassexport/cwt/east_000.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "west_180", output = "grassexport/cwt/west_180.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "subbasin_th1000", output = "grassexport/cwt/subbasin_th1000.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "roads", output = "grassexport/cwt/roads.tif", format = "GTiff", flags = "overwrite")

execGRASS("r.out.gdal", input = "stream_th1500", output = "grassexport/cwt/stream_th1500.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "stream_th500", output = "grassexport/cwt/stream_th500.tif", format = "GTiff", flags = "overwrite")
execGRASS("r.out.gdal", input = "stream_th400", output = "grassexport/cwt/stream_th400.tif", format = "GTiff", flags = "overwrite")
```

Crop Maps that were prepared in GRASS. Maps are cropped R because MASK command is not functioning properly for GRASS via R.
Original input maps are been cropped before processing worldfile and flowtable in R, without cropping the RHESSYs worldfile and flowtable preparation in the R environment will not function properly,

```{r Crop Maps that were Prepared in GRASS}

ws32<- raster("grassexport/cwt/basin_ws32.tif")
acc10<- raster("grassexport/cwt/acc10.tif")
patches<- raster("grassexport/cwt/patch.tif")
aspect10<- raster("grassexport/cwt/aspect10.tif")
dem10<- raster("grassexport/cwt/grass_dem10.tif")
dem10f<- raster("grassexport/cwt/dem10f.tif")
dir10<- raster("grassexport/cwt/dir10.tif")
drain10<- raster("grassexport/cwt/drain10.tif")
hillslope<- raster("grassexport/cwt/hillslope_th1000.tif")
roads<- brick("grassexport/cwt/roads.tif")
slope10<- raster("grassexport/cwt/slope10.tif")
streams<- raster("grassexport/cwt/stream_th1000.tif")
topidx10_100<- raster("grassexport/cwt/topidx10_100.tif")
e_horizon_1000 <- raster("grassexport/cwt/e_horizon_1000.tif")
w_horizon_1000 <- raster("grassexport/cwt/w_horizon_1000.tif")
subbasins<- raster("grassexport/cwt/subbasin_th1000.tif")

ws32polygon<- rasterToPolygons(ws32, fun = function(x){x==1}, dissolve = TRUE, digits = 12)

maskedws32 <- crop(mask(ws32,ws32polygon),ws32polygon)
maskedacc10 <- crop(mask(acc10,ws32polygon),ws32polygon)
maskedpatches <- crop(mask(patches,ws32polygon),ws32polygon)
maskedaspect10 <- crop(mask(aspect10,ws32polygon),ws32polygon)
maskeddem10 <- crop(mask(dem10,ws32polygon),ws32polygon)
maskeddem10f <- crop(mask(dem10f,ws32polygon),ws32polygon)
maskeddir10 <- crop(mask(dir10,ws32polygon),ws32polygon)
maskeddrain10 <- crop(mask(drain10,ws32polygon),ws32polygon)
maskedhillslope <- crop(mask(hillslope,ws32polygon),ws32polygon)
maskedroads <- crop(mask(roads,ws32polygon),ws32polygon)
maskedslope10 <- crop(mask(slope10,ws32polygon),ws32polygon)
maskedstreams <- crop(mask(streams,ws32polygon),ws32polygon)
maskedtopidx10_100 <- crop(mask(topidx10_100,ws32polygon),ws32polygon)
maskede_horizon_1000 <- crop(mask(e_horizon_1000,ws32polygon),ws32polygon)
maskedw_horizon_1000 <- crop(mask(w_horizon_1000,ws32polygon),ws32polygon)
maskedsubbasins<- crop(mask(subbasins,ws32polygon),ws32polygon)

## Save as tif

writeRaster(maskedws32,"grassexport/cwt_ws32/basin_ws32",format = "GTiff", overwrite = TRUE)
writeRaster(maskedacc10,"grassexport/cwt_ws32/acc10",format = "GTiff", overwrite = TRUE)
writeRaster(maskedpatches,"grassexport/cwt_ws32/patch",format = "GTiff", overwrite = TRUE)
writeRaster(maskedaspect10,"grassexport/cwt_ws32/aspect10",format = "GTiff", overwrite = TRUE)
writeRaster(maskeddem10,"grassexport/cwt_ws32/dem10",format = "GTiff", overwrite = TRUE)
writeRaster(maskeddem10f,"grassexport/cwt_ws32/dem10f",format = "GTiff", overwrite = TRUE)
writeRaster(maskeddir10,"grassexport/cwt_ws32/dir10",format = "GTiff", overwrite = TRUE)
writeRaster(maskeddrain10,"grassexport/cwt_ws32/drain10",format = "GTiff", overwrite = TRUE)
writeRaster(maskedhillslope,"grassexport/cwt_ws32/hillslope",format = "GTiff", overwrite = TRUE)
writeRaster(maskedroads,"grassexport/cwt_ws32/roads",format = "GTiff", overwrite = TRUE)
writeRaster(maskedslope10,"grassexport/cwt_ws32/slope10",format = "GTiff", overwrite = TRUE)
writeRaster(maskedstreams,"grassexport/cwt_ws32/streams",format = "GTiff", overwrite = TRUE)
writeRaster(maskedtopidx10_100,"grassexport/cwt_ws32/topidx10_100",format = "GTiff", overwrite = TRUE)
writeRaster(maskede_horizon_1000,"grassexport/cwt_ws32/e_horizon_1000",format = "GTiff", overwrite = TRUE)
writeRaster(maskedw_horizon_1000,"grassexport/cwt_ws32/w_horizon_1000",format = "GTiff", overwrite = TRUE)
writeRaster(maskedsubbasins,"grassexport/cwt_ws32/subbasins",format = "GTiff", overwrite = TRUE)


plot(maskedws32, main ="ws32")
plot(maskedpatches, main = "patches")
plot(maskedacc10, main = "acc10")
plot(maskedaspect10, main = "aspect10")
plot(maskedsubbasins, main = "subbasins")
plot(maskeddem10, main = "dem10")
plot(maskeddem10f, main = "dem10f")
plot(maskeddir10, main = "dir10")
plot(maskeddrain10, main = "drain10")
plot(maskedhillslope, main = "hillslope")
plot(maskedroads, main = "roads")
plot(maskedslope10, main = "slope10")
plot(maskedstreams, main = "streams")
plot(maskedtopidx10_100, main = "topidx10_100")
plot(maskede_horizon_1000, main = "e_horizon_1000")
plot(maskedw_horizon_1000, main = "w_horizon_1000")

```

Prepare SSURGO Soil Maps
SSURGO-via-SDA 
Code originally prepared by Dylan Beaudette
Download SSURGO data and make sure CRS/Extent/Crop are Correct for input into RHESSys

```{r Download and Prepare SSURGO Soil Maps}
getwd()

setwd(system.file("extdata/", package = "RHESSysIOinR"))

# load BBOX
x <- read_sf(watershedshapefile)
# get gSSURGO grid here
mu <- mukey.wcs(aoi = x, db = 'gssurgo')
# unique map unit keys
ll <- levels(mu)[[1]]
# note SSA boundary
levelplot(mu, att = 'ID', margin = FALSE, colorkey = FALSE, col.regions = viridis, main = "SSURGO Map Units")

## Note: some of these map units are dominated by non-soil components
# Dominant Component (Numeric) -> NODATA
# Weighted Average -> use any available data, but wt. mean are diluted (see source data)

# get thematic data from SDA
# dominant component
# depth-weighted average
# sand, silt, clay, AWC (RV)

p <-  get_SDA_property(property = c("sandtotal_r","silttotal_r","claytotal_r", "awc_r", "ksat_r"),
                       method = "Weighted Average", 
                       mukeys = ll$ID,
                       top_depth = 0,
                       bottom_depth = 200)

head(p)

# re-create raster attribute table with aggregate soil properties
rat <- merge(ll, p, by.x = 'ID', by.y = 'mukey', sort = FALSE, all.x = TRUE)
# re-pack RAT
levels(mu) <- rat
# convert raster + RAT --> stack of values
s <- deratify(mu, att = c("sandtotal_r", "silttotal_r", "claytotal_r", "awc_r", "ksat_r"))
# graphical check
levelplot(
  s[[1:3]], 
  main = 'Sand, Silt, Clay (RV) 0-200cm\nWeighted Average',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis
)

levelplot(
  s[[4]], 
  main = 'AWC (RV) 0-200cm\nWeighted Average',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis
)

levelplot(
  s[[5]], 
  main = 'ksat (RV) 0-200cm\nWeighted Average',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis
)




# convert to a representative soil texture class
txt.lut <- read.csv('http://soilmap2-1.lawr.ucdavis.edu/800m_grids/RAT/texture_2550.csv')
# make a copy
texture_060 <- s[[1]]
# note: soil textures that aren't present are dropped from factor levels
texture_060[] <- ssc_to_texcl(sand = s$sandtotal_r[], clay = s$claytotal_r[])
# extract RAT
rat <- levels(texture_060)[[1]]
# add colors
rat <- merge(rat, txt.lut, by.x = 'VALUE', by.y = 'class', all.x = TRUE, sort = FALSE)
# fix column order
rat <- rat[, c('ID', 'VALUE', 'hex', 'names')]
# re-pack
levels(texture_060) <- rat
# check: ok
cols <- levels(texture_060)[[1]]$hex
levelplot(texture_060, att = 'names', margin = FALSE, col.regions = cols, main = "Soil Textures") 


writeRaster(texture_060, file = 'C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt/ws32/soiltexture060.tif', overwrite = TRUE, options=c("COMPRESS=LZW"))

texture60raster<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt/ws32/soiltexture060.tif")

### this has been modified to use new SSURGO Inputs with deep-shallow depth classes

texture60raster<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt/ws32/ssurgo-soiltype-class.tif")

## reproject to raster mask instead

ws32<- raster("grassexport/cwt_ws32/basin_ws32.tif")

 newproj<- "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"
reproj60 <- projectRaster(from = texture60raster, crs = proj4string(ws32), method = 'ngb')

plot(texture60raster, zlim = c(1,5), main = "Texture Raster with modified Depth Classes")

{plot(reproj60, zlim = c(1,5), main = "Reprojected Texture Raster with modified Depth Classes and Watersheds")
plot(st_geometry(x), add = TRUE, col = NA)}

## prepare 10m resolution raster and resample prepared soil data to 10m
resample10<- raster(resolution=c(10,10), crs = proj4string(reproj60), ext=extent(reproj60))

reproj6010 <- resample(reproj60,resample10, method = 'ngb')

{plot(reproj6010, zlim = c(1,5), main = "Reprojected and Resampled Texture Raster with modified Depth Classes and Watersheds")
plot(st_geometry(x), add = TRUE, col = NA)}
## Crop prepared raster to extent of watershed of interest

## croppedtexture60 <- crop(reproj6010,extent(x[which(x$WS=='32'),]))

#for now cropping is completed based on delineated watershed extent from raster instead of watershed extent from watershed polygons
croppedtexture60 <- crop(reproj6010,extent(ws32))

# croppedtexture60 <- projectRaster(from = croppedtexture60, crs = newproj, method = 'ngb')

## Mask prepared raster using watershed polygon
#masked60 <- mask(croppedtexture60,x[which(x$WS=='32'),])

## for now masking is completed based on delineated watershed extent from raster instead of watershed extent from watershed polygons
ws32polygon<- rasterToPolygons(ws32, fun = function(x){x==1}, dissolve = TRUE, digits = 12)


extent(croppedtexture60)<- extent(ws32)



{plot(reproj6010, zlim = c(1,5), main = "Reprojected and Resampled Texture Raster with modified Depth Classes and Selected Watershed")
plot(ws32polygon, add = TRUE, col = NA)}

masked60 <- mask(croppedtexture60,ws32polygon)

plot(masked60, zlim = c(1,5), main = "Reprojected and Resampled Texture Raster with modified Depth Classes and Masked Selected Watershed")

plot(x[which(x$WS=='32'),])

plot(st_geometry(x[which(x$WS=='32'),]))

{plot(reproj60, zlim = c(1,5))
plot(st_geometry(x[which(x$WS=='32'),]), add = TRUE, col = NA)}






{plot(as.factor(croppedtexture60), zlim = c(1,5))
plot(st_geometry(x[which(x$WS=='32'),]), add = TRUE, col = NA)}

{plot(as.factor(masked60), zlim = c(1,5))
plot(st_geometry(x[which(x$WS=='32'),]), add = TRUE, col = NA)}


{plot(masked60, zlim = c(1,5), main = "Polygon Delineation")
plot(st_geometry(x[which(x$WS=='32'),]), add = TRUE, col = NA)}

{plot(masked60, zlim = c(1,5), main = "Watershed Delineation")
plot(ws32polygon, add = TRUE, col = NA)}
```

Prepare textural classes from sand and clay totals

```{r Prepare Soil Def files}
mapunittable<- levels(mu)[[1]]


mapunittable

mapunittable$textclass<- ssc_to_texcl(sand = mapunittable$sandtotal_r, clay = mapunittable$claytotal_r)


mapunittable



```

Code Prepared By Dylan Beaudette and modified

```{r Prepare DSM Soil Map from local file}

setwd(system.file("extdata/", package = "RHESSysIOinR"))

ws32<- raster("grassexport/cwt_ws32/basin_ws32.tif")

#("grassexport/cwt_ws32/ws32.tif")


# RSS: cell values are map unit keys
r <- raster('Raster soil survey/Coweeta_Final_raster.tif')

## for now, convert to UTM z17
r <- projectRaster(r, ws32, method = 'ngb')

# convert to raster + RAT
r <- ratify(r)

# RAT: raster attribute table
rat <- read.dbf('Raster soil survey/Coweeta_Final_raster.tif.vat.dbf', as.is = TRUE)
names(rat) <- tolower(names(rat))

# musym is the national mu symbol
rss.mu <- st_read('Raster soil survey/rss_nc/rss_nc.gdb', layer = 'mapunit')
rss.co <- st_read('Raster soil survey/rss_nc/rss_nc.gdb', layer = 'component')
rss.hz <- st_read('Raster soil survey/rss_nc/rss_nc.gdb', layer = 'chorizon')

## check for missing symbols
# none missing from RAT
setdiff(rat$MUSYM, rss.mu$musym)
# map unit table contains some extra
setdiff(rss.mu$musym, rat$MUSYM)

## subset child tables
rss.mu <- rss.mu[rss.mu$musym %in% rat$musym, ]
rss.co <- rss.co[rss.co$mukey %in% rss.mu$mukey, ]
rss.hz <- rss.hz[rss.hz$cokey %in% rss.co$cokey, ]

.dominantCondition <- function(i, v) {
  
  i <- i[i$compkind != 'Miscellaneous area', ]
  if(nrow(i) < 1) {
    return(NULL)
  }
  
  fm <- as.formula(sprintf("comppct_r ~ %s", v))
  a <- aggregate(fm, data = i, FUN = sum, na.rm = TRUE)
  
  idx <- order(a[['comppct_r']], decreasing = TRUE)[1]
  
  res <- data.frame(
    mukey = i$mukey[1],
    v = a[[v]][idx]
  )
  names(res) <- c('mukey', v)
  
  return(res)
}

.dominantValue <- function(i, v) {
  
  i <- i[i$compkind != 'Miscellaneous area', ]
  if(nrow(i) < 1) {
    return(NULL)
  }
  
  
  idx <- order(i[['comppct_r']], decreasing = TRUE)[1]
  
  res <- data.frame(
    mukey = i$mukey[1],
    v = i[[v]][idx]
  )
  
  names(res) <- c('mukey', v)
  
  return(res)
  
}

getDominantCondition <- function(x, v) {
  
  res <- lapply(
    split(rss.co, rss.co$mukey), 
    .dominantCondition, v = v
  )
  
  res <- do.call('rbind', res)
  
  return(res)
}

getDominantValue <- function(x, v) {
  
  res <- lapply(
    split(rss.co.aws050, rss.co.aws050$mukey), 
    .dominantValue, v = v
  )
  
  res <- do.call('rbind', res)
  
  return(res)
}

co.taxpartsize <- getDominantCondition(rss.co, v = 'taxpartsize')


co.spc <- rss.hz
depths(co.spc) <- cokey ~ hzdept_r + hzdepb_r
hzdesgnname(co.spc) <- 'hzname'

# at dZ = 1cm, use awc_r directly
co.spc$aws <- co.spc$awc_r * 1

a <- slab(co.spc, cokey ~ aws, slab.structure = c(0, 50), slab.fun = sum)

head(a)


rss.co.aws050 <- merge(rss.co, a, by = 'cokey', sort = FALSE)[, c('mukey', 'cokey', 'compkind', 'comppct_r', 'value')]

# no NA allowed in wt. mean / etc.
rss.co.aws050 <- rss.co.aws050[!is.na(rss.co.aws050$value), ]

co.aws050 <- getDominantValue(rss.co.aws050, v = 'value')

names(co.aws050) <- c('mukey', 'aws050')


mu.subset <- rss.mu[, c('mukey', 'musym', 'mukind')]

agg <- merge(mu.subset, co.taxpartsize, by = 'mukey', sort = FALSE)

agg <- merge(agg, co.aws050, by = 'mukey', sort = FALSE)

rat <- merge(rat, agg, by = 'musym', sort = FALSE)

# attempt to split out component / series names
rat$co.names <- stri_split_fixed(str = rat$muname,  pattern = ',', n = 2, simplify = TRUE)[, 1]
# this only works because all component names are single-word names
rat$co.names <- stri_split_fixed(str = rat$co.names,  pattern = ' ', n = 2, simplify = TRUE)[, 1]
# RAT management
ll.original <- levels(r)[[1]]
# merge and pack updated RAT
ll <- merge(ll.original, rat, by.x = 'ID', by.y = 'value', all.x = TRUE, sort = FALSE)
levels(r) <- ll

# convert select attributes to new raster objects via RAT + codes

r.taxpartsize <- deratify(r, att = 'taxpartsize')


plot(r.taxpartsize)



###quick and dirty incorporate new DSM map with two depth classes

r.taxpartsizetest<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt/ws32/rss-soiltype-class.tif")

r.taxpartsize <- projectRaster(r.taxpartsizetest, ws32, method = 'ngb')




ws32polygon<- rasterToPolygons(ws32, fun = function(x){x==1}, dissolve = TRUE, digits = 12)

maskeddsm <- mask(r.taxpartsize,ws32polygon)

plot(maskeddsm, main = "Masked DSM")


```

Reclassify Soil Maps

Default Texture Values in RHESSys
1 - Clay
2 - Silty Clay
3 - Silty Clay Loam
4 - Sandy Clay
5 - Sandy Clay Loam
6 - Clay Loam
7 - Silt
8 - Silty Loam
9 - Loam
10 - Sand
11 - Loamy Sand
12 - Sandy Loam
13 - Rock
14 - Water

Shallow Files Created and added to defs folder
19 - Shallow Sandy Clay Loam
23 - Shallow Loam
26 - Shallow Sandy Loam

Default Texture Values used by SDA
1 - loamy sand
2 - sandy loam 
3 - loam
4 - sandy clay loam
5 - clay loam

Default Texture used by DSM and quick and dirty conversions
1 - loamy         > loam
2 - fine-loamy    > silty clay loam
3 - coarse-loamy  > sandy loam


Current Textural Levels for Coweeta
6 Levels
1 - deep.sl
2- shallow.sl
3- deep.l
4- shallow.l
5- deep.scl
6- shallow.scl

```{r Reclassify Prepared Soil Maps}
# original before depth class substitution
#reclasssoil<- c(1,11,2,12,3,9,4,5,5,6,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0)

##this has been modified for quick implementation of shallow-deep classes
reclasssoil<- c(1,12,2,26,3,9,4,23,5,5,6,19)


reclasssoilmat<- matrix(reclasssoil, ncol = 2, byrow = TRUE)

reclasssoilmat

reclassreproj<- reclassify(masked60, reclasssoilmat)


plot(reclassreproj, main = "SSURGO DC Texture Dual Depth Method", zlim = c(1,24), col = viridis(24))

writeRaster(reclassreproj, file = 'grassexport/cwt_ws32/ssurgosoil.tif', overwrite = TRUE, options=c("COMPRESS=LZW"))

#plot(SoilsMap2, main = "SSURGO USACE Texture Method")


##this has been modified for quick implementation of shallow-deep classes
##original before depth class subsititution
#reclassdsm<- c(1,9,2,3,3,12,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0)
#new
 reclassdsm<- c(1,12,2,26,3,9,4,23,5,5,6,19)


reclassdsmmat<- matrix(reclassdsm, ncol = 2, byrow = TRUE)

reclassdsmmat

reclassmaskeddsm <- reclassify(maskeddsm, reclassdsmmat)

plot(reclassmaskeddsm, main = "DSM DC Texture Dual Depth Method", zlim = c(1,24), col = viridis(24))

writeRaster(reclassmaskeddsm, file = 'grassexport/cwt_ws32/dsmsoil.tif', overwrite = TRUE, options=c("COMPRESS=LZW"))

#plot(maskeddsm)



reclassstatic<- c(1,12,2,12,3,12,4,12,5,12,6,12,7,12,8,12,9,12,10,12,11,12,12,12,13,12,14,12)

reclassstaticmat<- matrix(reclassstatic, ncol = 2, byrow = TRUE)

reclassstaticmat

reclassmaskedstatic <- reclassify(maskeddsm, reclassstaticmat)

plot(reclassmaskedstatic, main = "Static Loam Texture", zlim = c(1,24), col = viridis(24))

```

NLCD Land Cover Classification Legend

11 Open Water
12 Perennial Ice/ Snow
21 Developed, Open Space
22 Developed, Low Intensity 
23 Developed, Medium Intensity
24 Developed, High Intensity
31 Barren Land (Rock/Sand/Clay)
41 Deciduous Forest
42 Evergreen Forest
43 Mixed Forest
51 Dwarf Scrub*
52 Shrub/Scrub
71 Grassland/Herbaceous
72 Sedge/Herbaceous*
73 Lichens*
74 Moss*
81 Pasture/Hay
82 Cultivated Crops
90 Woody Wetlands
95 Emergent Herbaceous Wetlands

* Alaska only

Because default RHESSys definition files are being used we will reclassify some of this land cover classification for our landscape

41 Deciduous Forest <- 3 veg_deciduous
42 Evergreen Forest <- 4 veg_evergreen
43 Mixed Forest <- 4 veg_evergreen

```{r Vegetation inputs from NLCD}

LANDCOVER<- get_nlcd(template = x.buff.gcs, label = 'coweeta', dataset = "landcover")
#CANOPY<- get_nlcd(template = x.buff.gcs, label = 'coweeta', year = 2016, dataset = "canopy")
IMPERVIOUS<- get_nlcd(template = x.buff.gcs, label = 'coweeta', dataset = "impervious")

plot(LANDCOVER, main = "NLCD Landcover")
#plot(CANOPY)
plot(IMPERVIOUS, main = "NLCD Impervious")

LANDCOVERREPROJ <-  projectRaster(from = LANDCOVER, crs = proj4string(ws32polygon), method = 'ngb')
#CANOPYREPROJ <-  projectRaster(from = CANOPY, crs = proj4string(ws32polygon), method = 'ngb')
IMPERVIOUSREPROJ <-  projectRaster(from = IMPERVIOUS, crs = proj4string(ws32polygon), method = 'ngb')




## prepare 10m resolution raster and resample prepared soil data to 10m
resample10<- raster(resolution=c(10,10), crs = proj4string(ws32polygon), ext=extent(ws32polygon))

LANDCOVERREPROJRES <- resample(LANDCOVERREPROJ,resample10, method = 'ngb')

{plot(LANDCOVERREPROJRES, main = "Reprojected and Resampled Texture Raster with modified Depth Classes and Watersheds")
plot(st_geometry(x), add = TRUE, col = NA)}



landcovercrop <- crop(LANDCOVERREPROJRES,ws32polygon)
#canopycrop <- crop(CANOPYREPROJ,ws32polygon)
imperviouscrop <- crop(IMPERVIOUSREPROJ,ws32polygon)

maskedlandcover <- mask(landcovercrop,ws32polygon)
#maskedcanopy <- mask(canopycrop,ws32polygon)
maskedimpervious <- mask(imperviouscrop,ws32polygon)


plot(maskedlandcover, main = "Masked Landcover")
#plot(maskedcanopy)
plot(maskedimpervious, main = "Masked Impervious")

{plot(maskedlandcover, main = "Masked Landcover with WS Polygon")
plot(ws32polygon, add = TRUE, col = NA)}

{plot(maskedimpervious, main = "Masked Impervious with WS Polygon")
plot(ws32polygon, add = TRUE, col = NA, border = "white")}



extent(LANDCOVER)
extent(LANDCOVERREPROJ)
extent(maskedlandcover)
extent(ws32polygon)


reclassveg<- c(11,3,12,3,21,3,22,3,23,3,24,3,31,3,41,3,42,4,43,4,51,3,52,3,71,3,72,3,73,3,74,3,81,3,82,3,90,3,95,3)

reclassvegmat<- matrix(reclassveg, ncol = 2, byrow = TRUE)

reclassvegmat

reclassmaskedveg <- reclassify(maskedlandcover, reclassvegmat)

plot(reclassmaskedveg, main = "Reclassified Vegetation", zlim = c(1,14), col = viridis(14))


writeRaster(reclassmaskedveg, file = 'grassexport/cwt_ws32/nlcdveg.tif', overwrite = TRUE, options=c("COMPRESS=LZW"))


```

Prescribe vegetation rooting depth

```{r Additional rooting depth information}
##max root depth seems to be in meters, not clearly defined but inferred from 2021 publication

maxrootdepth = 1

maxrootdepth<- as.data.frame(maxrootdepth)

colnames(maxrootdepth)<-"epc.max_root_depth"

change_def_file("defs/veg_deciduous.def", maxrootdepth, file_name_ext = NULL)
change_def_file("defs/veg_evergreen.def", maxrootdepth, file_name_ext = NULL)


```

LAI data from MODIS

modified from https://cran.r-project.org/web/packages/MODISTools/vignettes/modistools-vignette.html

```{r}
library(MODISTools)

bands <- mt_bands(product = "MOD15A2H")

head(bands)

dates <- mt_dates(product = "MOD15A2H", lat = 35 , lon = -83 )

dates

coweeta_lai <- mt_subset (product = "MOD15A2H", lat = 35.06, lon = -83.43,
                          band = "Lai_500m", start = "2017-01-01", end = "2018-06-01",
                          km_lr = 20, km_ab = 20, site_name="coweeta",
                          internal = TRUE, progress = FALSE)

coweeta_lc <- mt_subset (product = "MCD12Q1", lat = 35.06, lon = -83.43,
                          band = "LC_Type1", start = "2017-01-01", end = "2018-06-01",
                          km_lr = 20, km_ab = 20, site_name="coweeta",
                          internal = TRUE, progress = FALSE)

head(coweeta_lai)


coweetamodis <- coweeta_lc %>%
  rename("lc" = "value") %>%
  select("lc","pixel") %>%
  right_join(coweeta_lai, by = "pixel")

coweetamodis <- coweetamodis %>%
  filter(value <= 100,
         lc %in% c("1","5")) %>% 
  mutate(lc = ifelse(lc == 1, "ENF","DBF")) %>%
  group_by(lc, calendar_date) %>% 
  summarize(doy = as.numeric(format(as.Date(calendar_date)[1],"%j")),
            lai_mean = median(value * as.double(scale)))

ggplot(coweetamodis, aes(x = doy, y = lai_mean)) +
  geom_point() +
  geom_smooth(span = 0.3, method = "loess") +
  labs(x = "day of year (DOY)",
       y = "leaf area index (LAI)") +
  theme_minimal() +
  facet_wrap(~ lc)



coweeta_lai <- mt_subset (product = "MOD15A2H", lat = 35.06, lon = -83.43,
                          band = "Lai_500m", start = "2017-05-20", end = "2017-06-01",
                          km_lr = 20, km_ab = 20, site_name="coweeta",
                          internal = TRUE, progress = FALSE)



LAI_raster <- mt_to_raster(df=coweeta_lai, reproject = TRUE)



x <- read_sf(watershedshapefile)
x.buff <- st_as_sf(st_buffer(st_as_sfc(st_bbox(x)), dist = 1000))
x.gcs <- st_transform(x, 4326)
x.buff.gcs <- st_transform(x.buff, 4326)

{plot(LAI_raster)
   plot(st_geometry(x.buff.gcs), add = TRUE, col = NA, lwd = 2)
  plot(st_geometry(x.gcs), add = TRUE, col = NA)
  }



```

Create Templates for RHESSYs

```{r Template}
# template_read(template)
# would be useful to modify or read RHESSys template in R, currently template_read does not display nicely

# Create Templates for each Treatment

{templatetext<- "1
../defs/basin.def
1
../defs/hillslope.def
1
../defs/zone.def
14
../defs/soil_clay.def
../defs/soil_clayloam.def
../defs/soil_loam.def
../defs/soil_loamysand.def
../defs/soil_rock.def
../defs/soil_sand.def
../defs/soil_sandyclay.def
../defs/soil_sandyclayloam.def
../defs/soil_sandyloam.def
../defs/soil_silt.def
../defs/soil_siltyclay.def
../defs/soil_siltyclayloam.def
../defs/soil_siltyloam.def
../defs/soil_water.def
../defs/soil_shallowloam.def
../defs/soil_shallowsandyclayloam
../defs/soil_shallowsandyloam
1
../defs/lu_undev.def
9
../defs/veg_deciduous/veg_deciduous.def
../defs/veg_evergreen/veg_evergreen.def
../defs/veg_deciduous_BES.def
../defs/veg_eucalypt.def
../defs/veg_grass.def
../defs/veg_lawn_2cm.def
../defs/veg_lawn_5cm.def
../defs/veg_lawn_10cm.def
../defs/veg_nonveg.def
1
../clim/cwtws32extended.base
_world basin_ws32.tif 1
 _basin basin_ws32.tif 1
	x		value 0.0
	y		value 0.0
	z		aver dem10.tif
	basin_parm_ID	dvalue 1
	latitude	value 35.04 
	basin_n_basestations 	dvalue 0	
  	_hillslope subbasins.tif 1
		x		value 0.0
		y		value 0.0
		z		aver dem10.tif
		hill_parm_ID	dvalue 1	
		gw.storage	value 0.0
		gw.NO3		value 0.0
		hillslope_n_basestations	dvalue 0 	
		_zone patch.tif 1 
			x		  value 0.0
			y		  value 0.0
			z		  aver dem10.tif 
			zone_parm_ID  	  dvalue 1  
			area		  area	
			slope		  aver slope10.tif	
			aspect		  spavg aspect10.tif slope10.tif	
			precip_lapse_rate value 1.0
			e_horizon	  eqn 0.001 0 e_horizon_1000.tif 	
			w_horizon	  eqn 0.001 0 w_horizon_1000.tif	
			zone_n_basestations	  dvalue 1	
			zone_basestation_ID	  dvalue 101	
			 _patch patch.tif 1
				x			value 0.0
				y			value 0.0
				z			aver  dem10.tif
				soil_parm_ID	        mode ssurgosoil.tif	
				landuse_parm_ID		dvalue 1
				fire_parm_ID		value 1.0
				area			area	
				slope			aver  slope10.tif			
				lna 			eqn 0.001 0 topidx10_100.tif	
				Ksat_vertical   	value 1.0 
				mpar	        	value 0.12	
				rz_storage		value 0.0
				unsat_storage		value 0.0
				sat_deficit 		value 0.0
				snowpack.water_equivalent_depth value 0.28 
				snowpack.water_depth 	value 0.0
				snowpack.T 		value -10.0
				snowpack.surface_age 	value 0.0
				snowpack.energy_deficit value -0.5 
				litter.cover_fraction	value 1.0
				litter.rain_stored	value 0.00001544
				litter_cs.litr1c 	value 0.00158273
				litter_ns.litr1n 	value 0.00007521
				litter_cs.litr2c 	value 0.01056238
				litter_cs.litr3c 	value 0.00094835
				litter_cs.litr4c 	value 0.00641051
				soil_cs.soil1c 		value 0.00428524
				soil_ns.sminn		value 0.00002811
				soil_ns.nitrate		value 0.00003044
				soil_cs.soil2c		value 0.00304513
				soil_cs.soil3c  	value 0.05220800
				soil_cs.soil4c		value 0.37839627
				patch_n_basestations		dvalue 0
				_canopy_strata patch.tif 1 	
					veg_parm_ID		mode nlcdveg.tif	
            				cover_fraction		value 1.0
					gap_fraction		value 0.0 
					rootzone.depth		value 1.0 
					snow_stored		value 0.0 
					rain_stored		value 0.0 
					cs.pool			value 0.0 
					cs.leafc		value 0.0 
					cs.dead_leafc		value 0.0 
					cs.leafc_store		value 0.0 
					cs.leafc_transfer	value 0.0 
					cs.live_stemc		value 0.0 
					cs.livestemc_store	value 0.0 
					cs.live.stemc_transfer	value 0.0 
					cs.dead_stem		value 0.0 
					cs.deadstemc_store	value 0.0 
					cs.deadstemc_transfer	value 0.0 
					cs.live_crootc		value 0.0 
					cs.livecrootc_store	value 0.0 
					cs.livecrootc_transfer	value 0.0 
					cs.dead_crootc		value 2.0 
					cs.deadcrootc_store	value 0.0 
					cs.deadcrootc_transfer	value 0.0 
					cs.frootc		value 0.0 
					cs.frootc_store		value 0.0 
					cs.frootc_transfer	value 0.0 
					cs_cwdc			value 0.0 
					epv.prev_leafcalloc	value 0.0 
					ns.pool			value 0.0 
					ns.leafn		value 0.0 
					ns.dead_leafn		value 0.0 
					ns.leafn_store		value 0.0 
					ns.leafn_transfer	value 0.0 
					ns.live_stemn		value 0.0 
					ns.livestemn_store	value 0.0 
					ns.livestemn_transfer	value 0.0 
					ns.dead_stem		value 0.0 
					ns.deadstemn_store	value 0.0 
					ns.deadstemn_transfer	value 0.0 
					ns.live_crootn		value 0.0 
					ns.livecrootn_store	value 0.0 
					ns.livecrootn_transfer	value 0.0 
					ns.dead_crootn		value 0.0 
					ns.deadcrootn_store	value 0.0 
					ns.deadcrootn_transfer	value 0.0 
					ns.frootn		value 0.0 
					ns.frootn_store		value 0.0 
					ns.frootn_transfer	value 0.0 
					ns.cwdn			value 0.0 
					ns.retransn		value 0.0 
					epv.wstress_days      	dvalue 0  
					epv.min_fparabs		value 0.0 
					epv.min_vwc		value 0.0 
					canopy_strata_n_basestations dvalue 0 


"}

write(templatetext,file = "templates/RHESSYSinR_Coweeta_WS32_Spinup.template")

#Static
{templatestatic<- "1
../defs/basin.def
1
../defs/hillslope.def
1
../defs/zone.def
14
../defs/soil_clay.def
../defs/soil_clayloam.def
../defs/soil_loam.def
../defs/soil_loamysand.def
../defs/soil_rock.def
../defs/soil_sand.def
../defs/soil_sandyclay.def
../defs/soil_sandyclayloam.def
../defs/soil_sandyloam.def
../defs/soil_silt.def
../defs/soil_siltyclay.def
../defs/soil_siltyclayloam.def
../defs/soil_siltyloam.def
../defs/soil_water.def
../defs/soil_shallowloam.def
../defs/soil_shallowsandyclayloam
../defs/soil_shallowsandyloam
1
../defs/lu_undev.def
2
../defs/veg_deciduous/veg_deciduous.def
../defs/veg_evergreen/veg_evergreen.def
1
../clim/cwtws32extended.base
_world basin_ws32.tif 1
 _basin basin_ws32.tif 1
	x		value 0.0
	y		value 0.0
	z		aver dem10.tif
	basin_parm_ID	dvalue 1
	latitude	value 35.04 
	basin_n_basestations 	dvalue 0	
  	_hillslope subbasins.tif 1
		x		value 0.0
		y		value 0.0
		z		aver dem10.tif
		hill_parm_ID	dvalue 1	
		gw.storage	value 0.0
		gw.NO3		value 0.0
		hillslope_n_basestations	dvalue 0 	
		_zone patch.tif 1 
			x		  value 0.0
			y		  value 0.0
			z		  aver dem10.tif 
			zone_parm_ID  	  dvalue 1  
			area		  area	
			slope		  aver slope10.tif	
			aspect		  spavg aspect10.tif slope10.tif	
			precip_lapse_rate value 1.0
			e_horizon	  eqn 0.001 0 e_horizon_1000.tif 	
			w_horizon	  eqn 0.001 0 w_horizon_1000.tif	
			zone_n_basestations	  dvalue 1	
			zone_basestation_ID	  dvalue 101	
			 _patch patch.tif 1
				x			value 0.0
				y			value 0.0
				z			aver  dem10.tif
				soil_parm_ID	        dvalue 9	
				landuse_parm_ID		dvalue 1
				fire_parm_ID		value 1.0
				area			area	
				slope			aver  slope10.tif			
				lna 			eqn 0.001 0 topidx10_100.tif	
				Ksat_vertical   	value 1.0 
				mpar	        	value 0.12	
				rz_storage		value 0.0
				unsat_storage		value 0.0
				sat_deficit 		value 0.0
				snowpack.water_equivalent_depth value 0.28 
				snowpack.water_depth 	value 0.0
				snowpack.T 		value -10.0
				snowpack.surface_age 	value 0.0
				snowpack.energy_deficit value -0.5 
				litter.cover_fraction	value 1.0
				litter.rain_stored	value 0.00001544
				litter_cs.litr1c 	value 0.00158273
				litter_ns.litr1n 	value 0.00007521
				litter_cs.litr2c 	value 0.01056238
				litter_cs.litr3c 	value 0.00094835
				litter_cs.litr4c 	value 0.00641051
				soil_cs.soil1c 		value 0.00428524
				soil_ns.sminn		value 0.00002811
				soil_ns.nitrate		value 0.00003044
				soil_cs.soil2c		value 0.00304513
				soil_cs.soil3c  	value 0.05220800
				soil_cs.soil4c		value 0.37839627
				patch_n_basestations		dvalue 0
				_canopy_strata patch.tif 1 	
					veg_parm_ID		mode nlcdveg.tif	
            				cover_fraction		value 1.0
					gap_fraction		value 0.0 
					rootzone.depth		value 1.0 
					snow_stored		value 0.0 
					rain_stored		value 0.0 
					cs.pool			value 0.0 
					cs.leafc		value 0.0 
					cs.dead_leafc		value 0.0 
					cs.leafc_store		value 0.0 
					cs.leafc_transfer	value 0.0 
					cs.live_stemc		value 0.0 
					cs.livestemc_store	value 0.0 
					cs.live.stemc_transfer	value 0.0 
					cs.dead_stem		value 0.0 
					cs.deadstemc_store	value 0.0 
					cs.deadstemc_transfer	value 0.0 
					cs.live_crootc		value 0.0 
					cs.livecrootc_store	value 0.0 
					cs.livecrootc_transfer	value 0.0 
					cs.dead_crootc		value 2.0 
					cs.deadcrootc_store	value 0.0 
					cs.deadcrootc_transfer	value 0.0 
					cs.frootc		value 0.0 
					cs.frootc_store		value 0.0 
					cs.frootc_transfer	value 0.0 
					cs_cwdc			value 0.0 
					epv.prev_leafcalloc	value 0.0 
					ns.pool			value 0.0 
					ns.leafn		value 0.0 
					ns.dead_leafn		value 0.0 
					ns.leafn_store		value 0.0 
					ns.leafn_transfer	value 0.0 
					ns.live_stemn		value 0.0 
					ns.livestemn_store	value 0.0 
					ns.livestemn_transfer	value 0.0 
					ns.dead_stem		value 0.0 
					ns.deadstemn_store	value 0.0 
					ns.deadstemn_transfer	value 0.0 
					ns.live_crootn		value 0.0 
					ns.livecrootn_store	value 0.0 
					ns.livecrootn_transfer	value 0.0 
					ns.dead_crootn		value 0.0 
					ns.deadcrootn_store	value 0.0 
					ns.deadcrootn_transfer	value 0.0 
					ns.frootn		value 0.0 
					ns.frootn_store		value 0.0 
					ns.frootn_transfer	value 0.0 
					ns.cwdn			value 0.0 
					ns.retransn		value 0.0 
					epv.wstress_days      	dvalue 0  
					epv.min_fparabs		value 0.0 
					epv.min_vwc		value 0.0 
					canopy_strata_n_basestations dvalue 0 


"}
#SSURGO
{templatessurgo<- "1
../defs/basin.def
1
../defs/hillslope.def
1
../defs/zone.def
14
../defs/soil_clay.def
../defs/soil_clayloam.def
../defs/soil_loam.def
../defs/soil_loamysand.def
../defs/soil_rock.def
../defs/soil_sand.def
../defs/soil_sandyclay.def
../defs/soil_sandyclayloam.def
../defs/soil_sandyloam.def
../defs/soil_silt.def
../defs/soil_siltyclay.def
../defs/soil_siltyclayloam.def
../defs/soil_siltyloam.def
../defs/soil_water.def
../defs/soil_shallowloam.def
../defs/soil_shallowsandyclayloam
../defs/soil_shallowsandyloam
1
../defs/lu_undev.def
2
../defs/veg_deciduous/veg_deciduous.def
../defs/veg_evergreen/veg_evergreen.def
1
../clim/cwtws32extended.base
_world basin_ws32.tif 1
 _basin basin_ws32.tif 1
	x		value 0.0
	y		value 0.0
	z		aver dem10.tif
	basin_parm_ID	dvalue 1
	latitude	value 35.04 
	basin_n_basestations 	dvalue 0	
  	_hillslope subbasins.tif 1
		x		value 0.0
		y		value 0.0
		z		aver dem10.tif
		hill_parm_ID	dvalue 1	
		gw.storage	value 0.0
		gw.NO3		value 0.0
		hillslope_n_basestations	dvalue 0 	
		_zone patch.tif 1 
			x		  value 0.0
			y		  value 0.0
			z		  aver dem10.tif 
			zone_parm_ID  	  dvalue 1  
			area		  area	
			slope		  aver slope10.tif	
			aspect		  spavg aspect10.tif slope10.tif	
			precip_lapse_rate value 1.0
			e_horizon	  eqn 0.001 0 e_horizon_1000.tif 	
			w_horizon	  eqn 0.001 0 w_horizon_1000.tif	
			zone_n_basestations	  dvalue 1	
			zone_basestation_ID	  dvalue 101	
			 _patch patch.tif 1
				x			value 0.0
				y			value 0.0
				z			aver  dem10.tif
				soil_parm_ID	        mode ssurgosoil.tif	
				landuse_parm_ID		dvalue 1
				fire_parm_ID		value 1.0
				area			area	
				slope			aver  slope10.tif			
				lna 			eqn 0.001 0 topidx10_100.tif	
				Ksat_vertical   	value 1.0 
				mpar	        	value 0.12	
				rz_storage		value 0.0
				unsat_storage		value 0.0
				sat_deficit 		value 0.0
				snowpack.water_equivalent_depth value 0.28 
				snowpack.water_depth 	value 0.0
				snowpack.T 		value -10.0
				snowpack.surface_age 	value 0.0
				snowpack.energy_deficit value -0.5 
				litter.cover_fraction	value 1.0
				litter.rain_stored	value 0.00001544
				litter_cs.litr1c 	value 0.00158273
				litter_ns.litr1n 	value 0.00007521
				litter_cs.litr2c 	value 0.01056238
				litter_cs.litr3c 	value 0.00094835
				litter_cs.litr4c 	value 0.00641051
				soil_cs.soil1c 		value 0.00428524
				soil_ns.sminn		value 0.00002811
				soil_ns.nitrate		value 0.00003044
				soil_cs.soil2c		value 0.00304513
				soil_cs.soil3c  	value 0.05220800
				soil_cs.soil4c		value 0.37839627
				patch_n_basestations		dvalue 0
				_canopy_strata patch.tif 1 	
					veg_parm_ID		mode nlcdveg.tif	
            				cover_fraction		value 1.0
					gap_fraction		value 0.0 
					rootzone.depth		value 1.0 
					snow_stored		value 0.0 
					rain_stored		value 0.0 
					cs.pool			value 0.0 
					cs.leafc		value 0.0 
					cs.dead_leafc		value 0.0 
					cs.leafc_store		value 0.0 
					cs.leafc_transfer	value 0.0 
					cs.live_stemc		value 0.0 
					cs.livestemc_store	value 0.0 
					cs.live.stemc_transfer	value 0.0 
					cs.dead_stem		value 0.0 
					cs.deadstemc_store	value 0.0 
					cs.deadstemc_transfer	value 0.0 
					cs.live_crootc		value 0.0 
					cs.livecrootc_store	value 0.0 
					cs.livecrootc_transfer	value 0.0 
					cs.dead_crootc		value 2.0 
					cs.deadcrootc_store	value 0.0 
					cs.deadcrootc_transfer	value 0.0 
					cs.frootc		value 0.0 
					cs.frootc_store		value 0.0 
					cs.frootc_transfer	value 0.0 
					cs_cwdc			value 0.0 
					epv.prev_leafcalloc	value 0.0 
					ns.pool			value 0.0 
					ns.leafn		value 0.0 
					ns.dead_leafn		value 0.0 
					ns.leafn_store		value 0.0 
					ns.leafn_transfer	value 0.0 
					ns.live_stemn		value 0.0 
					ns.livestemn_store	value 0.0 
					ns.livestemn_transfer	value 0.0 
					ns.dead_stem		value 0.0 
					ns.deadstemn_store	value 0.0 
					ns.deadstemn_transfer	value 0.0 
					ns.live_crootn		value 0.0 
					ns.livecrootn_store	value 0.0 
					ns.livecrootn_transfer	value 0.0 
					ns.dead_crootn		value 0.0 
					ns.deadcrootn_store	value 0.0 
					ns.deadcrootn_transfer	value 0.0 
					ns.frootn		value 0.0 
					ns.frootn_store		value 0.0 
					ns.frootn_transfer	value 0.0 
					ns.cwdn			value 0.0 
					ns.retransn		value 0.0 
					epv.wstress_days      	dvalue 0  
					epv.min_fparabs		value 0.0 
					epv.min_vwc		value 0.0 
					canopy_strata_n_basestations dvalue 0 


"}
#DSM
{templatedsm<- "1
../defs/basin.def
1
../defs/hillslope.def
1
../defs/zone.def
14
../defs/soil_clay.def
../defs/soil_clayloam.def
../defs/soil_loam.def
../defs/soil_loamysand.def
../defs/soil_rock.def
../defs/soil_sand.def
../defs/soil_sandyclay.def
../defs/soil_sandyclayloam.def
../defs/soil_sandyloam.def
../defs/soil_silt.def
../defs/soil_siltyclay.def
../defs/soil_siltyclayloam.def
../defs/soil_siltyloam.def
../defs/soil_water.def
../defs/soil_shallowloam.def
../defs/soil_shallowsandyclayloam
../defs/soil_shallowsandyloam
1
../defs/lu_undev.def
1
../defs/veg_deciduous/veg_deciduous.def
../defs/veg_evergreen/veg_evergreen.def
1
../clim/cwtws32extended.base
_world basin_ws32.tif 1
 _basin basin_ws32.tif 1
	x		value 0.0
	y		value 0.0
	z		aver dem10.tif
	basin_parm_ID	dvalue 1
	latitude	value 35.04 
	basin_n_basestations 	dvalue 0	
  	_hillslope subbasins.tif 1
		x		value 0.0
		y		value 0.0
		z		aver dem10.tif
		hill_parm_ID	dvalue 1	
		gw.storage	value 0.0
		gw.NO3		value 0.0
		hillslope_n_basestations	dvalue 0 	
		_zone patch.tif 1 
			x		  value 0.0
			y		  value 0.0
			z		  aver dem10.tif 
			zone_parm_ID  	  dvalue 1  
			area		  area	
			slope		  aver slope10.tif	
			aspect		  spavg aspect10.tif slope10.tif	
			precip_lapse_rate value 1.0
			e_horizon	  eqn 0.001 0 e_horizon_1000.tif 	
			w_horizon	  eqn 0.001 0 w_horizon_1000.tif	
			zone_n_basestations	  dvalue 1	
			zone_basestation_ID	  dvalue 101	
			 _patch patch.tif 1
				x			value 0.0
				y			value 0.0
				z			aver  dem10.tif
				soil_parm_ID	        mode dsmsoil.tif	
				landuse_parm_ID		dvalue 1
				fire_parm_ID		value 1.0
				area			area	
				slope			aver  slope10.tif			
				lna 			eqn 0.001 0 topidx10_100.tif	
				Ksat_vertical   	value 1.0 
				mpar	        	value 0.12	
				rz_storage		value 0.0
				unsat_storage		value 0.0
				sat_deficit 		value 0.0
				snowpack.water_equivalent_depth value 0.28 
				snowpack.water_depth 	value 0.0
				snowpack.T 		value -10.0
				snowpack.surface_age 	value 0.0
				snowpack.energy_deficit value -0.5 
				litter.cover_fraction	value 1.0
				litter.rain_stored	value 0.00001544
				litter_cs.litr1c 	value 0.00158273
				litter_ns.litr1n 	value 0.00007521
				litter_cs.litr2c 	value 0.01056238
				litter_cs.litr3c 	value 0.00094835
				litter_cs.litr4c 	value 0.00641051
				soil_cs.soil1c 		value 0.00428524
				soil_ns.sminn		value 0.00002811
				soil_ns.nitrate		value 0.00003044
				soil_cs.soil2c		value 0.00304513
				soil_cs.soil3c  	value 0.05220800
				soil_cs.soil4c		value 0.37839627
				patch_n_basestations		dvalue 0
				_canopy_strata patch.tif 1 	
					veg_parm_ID		mode nlcdveg.tif	
            				cover_fraction		value 1.0
					gap_fraction		value 0.0 
					rootzone.depth		value 1.0 
					snow_stored		value 0.0 
					rain_stored		value 0.0 
					cs.pool			value 0.0 
					cs.leafc		value 0.0 
					cs.dead_leafc		value 0.0 
					cs.leafc_store		value 0.0 
					cs.leafc_transfer	value 0.0 
					cs.live_stemc		value 0.0 
					cs.livestemc_store	value 0.0 
					cs.live.stemc_transfer	value 0.0 
					cs.dead_stem		value 0.0 
					cs.deadstemc_store	value 0.0 
					cs.deadstemc_transfer	value 0.0 
					cs.live_crootc		value 0.0 
					cs.livecrootc_store	value 0.0 
					cs.livecrootc_transfer	value 0.0 
					cs.dead_crootc		value 2.0 
					cs.deadcrootc_store	value 0.0 
					cs.deadcrootc_transfer	value 0.0 
					cs.frootc		value 0.0 
					cs.frootc_store		value 0.0 
					cs.frootc_transfer	value 0.0 
					cs_cwdc			value 0.0 
					epv.prev_leafcalloc	value 0.0 
					ns.pool			value 0.0 
					ns.leafn		value 0.0 
					ns.dead_leafn		value 0.0 
					ns.leafn_store		value 0.0 
					ns.leafn_transfer	value 0.0 
					ns.live_stemn		value 0.0 
					ns.livestemn_store	value 0.0 
					ns.livestemn_transfer	value 0.0 
					ns.dead_stem		value 0.0 
					ns.deadstemn_store	value 0.0 
					ns.deadstemn_transfer	value 0.0 
					ns.live_crootn		value 0.0 
					ns.livecrootn_store	value 0.0 
					ns.livecrootn_transfer	value 0.0 
					ns.dead_crootn		value 0.0 
					ns.deadcrootn_store	value 0.0 
					ns.deadcrootn_transfer	value 0.0 
					ns.frootn		value 0.0 
					ns.frootn_store		value 0.0 
					ns.frootn_transfer	value 0.0 
					ns.cwdn			value 0.0 
					ns.retransn		value 0.0 
					epv.wstress_days      	dvalue 0  
					epv.min_fparabs		value 0.0 
					epv.min_vwc		value 0.0 
					canopy_strata_n_basestations dvalue 0 


"}

write(templatestatic,file = "templates/RHESSYSinR_Coweeta_WS32_static.template")
write(templatetext,file = "templates/RHESSYSinR_Coweeta_WS32_ssurgo.template")
write(templatedsm,file = "templates/RHESSYSinR_Coweeta_WS32_dsm.template")

```

Locate RHESSys Spatial Inputs and Specify Template to be used

Create RHESSys Worldfile and Flowtable for 7.4 based on Spatial Inputs and Template

Raster files and template information are used to setup RHESSys worldfile.
Flowtable created by "RHESSysPreprocess" must be converted to work. Unsure why.
Preprocessing is controlled by template file.

Template file 'CWWS32_STATIC.template' is used to run model normally
template file 'CWWS32_STATICspinup.template' is used to spin up model. Only difference is artificially extended climate dataset. 

# must setup automatic spinup and preprocessing for all treatments, right now spinup requires manual template input and 2 runs for creation

```{r RHESSys PreProcess and Flowtable Conversion, verbose = FALSE}
#setwd(system.file("extdata/", package = "RHESSysIOinR"))

type = "raster"
typepars = "grassexport/cwt_ws32"
template = "templates/RHESSYSinR_Coweeta_WS32_dsm.template"
# Suffixes of .world, .flow, and .meta will be appended to the worldfile, flowtable, and metadata files respectively.
name = "CWWS32"
overwrite =  TRUE
streams = "streams.tif"
# Optional Flowtable Spatial Data
roads = "roads.tif"
# impervious = "impervious_map"
# roofs = "roofs_map"
header = TRUE

# With certain configurations roads does not work. Returns message: road width cannot be 0 during preprocessing

RHESSysPreprocess(
  template = template,
  name = name,
  type = type,
  typepars = typepars,
  streams = streams,
  overwrite = overwrite,
  header = header,
  parallel = FALSE,
  make_stream = TRUE)

## Make sure to have parallel turned off  when preprocessing, convert flowtables after creation for compatibility
convert_flowtable("CWWS32.flow","CWWS321.flow",make_stream=4)

```

Setup RHESSys Inputs/Outputs for Spinup
Note that flowtable is converted flowtable. Using original flow table will result in errors.

Original spinup 0219 to 2017. Modified output to 1776-2017 to test code without very long spin-up.
Climate files have been modified to original DAYMET timeseries. 

```{r RHESsys Spinup Configuration}

## Read climate file to see length available climate data
read_clim("clim/cwtws32extended.rain", dates_out=TRUE)
read_clim("clim/cwtws32local.rain", dates_out=TRUE)

# Begin RHESSys Spinup
##Short Spinup, original spinup run 1776-2018

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32.world",
  world_hdr_prefix = "CWWS32",
  flowtable = "CWWS321.flow",
  start = "1775 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32",
  commandline_options = c("-b -g"))

input_tec_data = IOin_tec_std(start = "1776 11 1 1",
                              end = "2018 11 1 1",
                              output_state = TRUE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32extended.base")

##suggested standard hydrologic spinup parameters from rhessys wiki, gw values modified based on previous results from Coweeta Landscape

stdpars<- IOin_std_pars( 
            m = 1,
            k = 10,
            soil_dep= 0.4,
            m_v = 1,
            k_v = 1,
            gw1 = 0.15,
            gw2 = 0.35)


```

Run Spinup

Spinup runs model on one processor for x number of years. Takes a very long time. 

Spinup has been turned off for the purposes of this demonstration. Using previously spun up file ~ 12 hours, run multiple times.

```{r Spinup Run, eval=FALSE, include=FALSE}

start_time = Sys.time()
run_rhessys_single(input_rhessys = input_rhessys,
                   hdr_files = input_hdr,
                   tec_data = input_tec_data,
                   std_pars = stdpars,
                   runID = 'spinup')
end_time = Sys.time()
end_time - start_time

```

Run Spinup again 

```{r Spinup again with created worldfile, eval=FALSE, include=FALSE}

setwd(system.file("extdata/", package = "RHESSysIOinR"))


input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32.world.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32",
  flowtable = "CWWS321.flow",
  start = "1775 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32",
  commandline_options = c("-b -g"))


start_time = Sys.time()
run_rhessys_single(input_rhessys = input_rhessys,
                   hdr_files = input_hdr,
                   tec_data = input_tec_data,
                   std_pars = stdpars,
                   runID = 'spinup')
end_time = Sys.time()
end_time - start_time


```

Read Spinup and confirm that Soil C and Soil N have stabilized

```{r Read RHESSys Spinup}
setwd(system.file("extdata/", package = "RHESSysIOinR"))
spinupoutput<- readin_rhessys_output("out/cwws32dsm_rundsmspinup")
#spinupoutput<- readin_rhessys_output("out/cwws32ssurgo_runssurgospinup")

spinupoutput$bd$date <- make_date(year=spinupoutput$bd$year, month = spinupoutput$bd$month, day = spinupoutput$bd$day)
spinupoutput$bdg$date <- make_date(year=spinupoutput$bdg$year, month = spinupoutput$bdg$month, day = spinupoutput$bdg$day)

range(spinupoutput$bd$year)

plot(spinupoutput$bd$streamflow, type = "l")

plot(spinupoutput$bd$date,spinupoutput$bd$streamflow, type = "l", col = 'black', main = "Predicted Streamflow",
    xlab = "Date", ylab = "Streamflow mm")

plot(spinupoutput$bdg$date, spinupoutput$bdg$lai, type = "l", main = "LAI", xlab = "Date")
{plot(spinupoutput$bdg$soilc~spinupoutput$bdg$date,type = "l", main = "Spinup Soil Carbon", xlab = "Date")
soilctrend <- glm(spinupoutput$bdg$soilc~spinupoutput$bdg$date)
abline(soilctrend, col = 'red')}
{plot(spinupoutput$bdg$date,spinupoutput$bdg$soiln, type = "l", main = "Spinup Soil Nitrogen", xlab = "Date")
soilntrend <- glm(spinupoutput$bdg$soiln~spinupoutput$bdg$date)
abline(soilntrend , col = 'green')}

#prepped<- readin_rhessys_output("G:/Coweeta W32/output/basicspinupws32")


```

Configure RHESSys Inputs/Outputs for a single run.

Use World Statefile created during spin-up. To run model one time at patch scale.

 COMMAND LINE OPTIONS

-b		Basin output option.  Print out response variables for specified basins. 
-c		Canopy stratum output option.  Print out response variables for specified strata. 
-g		Grow option.  Try to read in dynamic bgc input data and output dynamic bgc parameters. 
-h    Hillslope output option.  Print out response variables for specified hillslopes. 
-p		Patch output option.  Print out response variables for specified patches. 
-r		Routing option. Gives name of flow_table to define explicit routing connectivity.  Also trigger use of explicit routing over TOPMODEL approach. 
-c		Stratum output option.  Print out response variables for specified strata. 

```{r Configure RHESSys Inputs using Created Worldfile}

#  "CWWS32.world.Y2018M10D31H1.state" - 1 Spinup run
# "CWWS32.world.Y2018M10D31H1.state.Y2018M10D31H1.state" - 2 spinup runs


read_clim("clim/cwtws32daymet.rain", dates_out = TRUE)


input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32dsm.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32dsm",
  flowtable = "CWWS32dsm1.flow",
  start = "2014 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32dsm",
  commandline_options = c("-b -p"))


## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created

input_tec_data = IOin_tec_std(start = "2015 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


stdpars<- IOin_std_pars(
            m = 1.75,
            k = 18.69,
            soil_dep= 0.48,
            m_v = 2.55,
            k_v = 7.54,
            gw1 = 0.19,
            gw2 = 0.29,
            pa = 0.17,
            po = 1.02,
            vgseng1 = 1.61,
            vgseng2 = 1.94,
            vgseng3 = 0.72)

```

Run RHESSys once

```{r Run Rhessys Once, include=FALSE}

start_time = Sys.time()
start_time
run_rhessys_single(input_rhessys = input_rhessys,
                   hdr_files = input_hdr,
                   tec_data = input_tec_data,
                   std_pars = stdpars,
                   runID = 'single')
end_time = Sys.time()
end_time - start_time
end_time

```

Read RHESSys Single Run Output

```{r Read in RHESSys Output}

getwd()

singleruntest<- readin_rhessys_output("out/cwws32_runsingle")

plot(singleruntest$bd$streamflow~singleruntest$bd$date, type = "l", main = "Streamflow", xlab = "Date", ylab = "Streamflow", col = 'DarkBlue')

plot(as.Date(singleruntest$bd$date),singleruntest$bd$rz_storage, type = "l", col = 'black', main = "Basin Scale Root Zone Storage",
    xlab = "Date", ylab = "mm")

#basin scale soil moisture
plot(singleruntest$bd$rz_storage/singleruntest$bdg$root_depth~singleruntest$bd$date, type = "l", main = "RZ_Storage/Root_Depth x Date", xlab = "Date", ylab = "rz_Storage/root_depth", col = 'brown')

plot(singleruntest$bd$lai~singleruntest$bd$date, type = "l", main = "LAI", xlab = "Date", ylab = "LAI", col = 'DarkGreen')
plot(singleruntest$bd$pet~singleruntest$bd$date, type = "l", main = "Potential Evapotranspiration", xlab = "Date", ylab = "PET", col = 'DarkBlue')
plot(singleruntest$bd$et~singleruntest$bd$date, type = "l", main = "Evapotranspiration", xlab = "Date", ylab = "ET", col = 'darkslategray')

plot((singleruntest$bd$unsat_stor/singleruntest$bd$sat_def_z)~singleruntest$bd$date, type = "l", main = "unsat_stor/sat_def_z", xlab = "Date", ylab = "vwc", col = 'DarkGreen')


```

Plot and Filter Observed Soil Moisture

```{r Read, Filter and Plot Observed Soil Moisture}

## Data has not been pre-prepared and must be cleaned

smws32_1<- read.delim("C:/Users/Carlos/Desktop/ORISE/Soil Moisture Data/CW/knb-lter-cwt.1308.19/CWT_132_1_0.txt", header = T)
smws32_2<- read.delim("C:/Users/Carlos/Desktop/ORISE/Soil Moisture Data/CW/knb-lter-cwt.1308.19/CWT_232_1_1308.txt", header = T)
smws32_3<- read.delim("C:/Users/Carlos/Desktop/ORISE/Soil Moisture Data/CW/knb-lter-cwt.1308.19/CWT_332_1_1308.txt", header = T)

smws32_1$Date<- as.Date(smws32_1$Date)
smws32_2$Date<- as.Date(smws32_2$Date)
smws32_3$Date<- as.Date(smws32_3$Date)

smws32_1 <- smws32_1[,!sapply(smws32_1,is.character)]
smws32_2 <- smws32_2[,!sapply(smws32_2,is.character)]
smws32_3 <- smws32_3[,!sapply(smws32_3,is.character)]

#range(smws32_3$smois30A)

smws32_1mean<- aggregate(smws32_1, by = list(smws32_1$Date), FUN = function(x) mean(x, na.rm = TRUE))
smws32_2mean<- aggregate(smws32_2, by = list(smws32_2$Date), FUN = function(x) mean(x, na.rm = TRUE))
smws32_3mean<- aggregate(smws32_3, by = list(smws32_3$Date), FUN = function(x) mean(x, na.rm = TRUE))

smws32_1mean <- smws32_1mean[order(smws32_1mean$Date),]
smws32_2mean <- smws32_2mean[order(smws32_2mean$Date),]
smws32_3mean <- smws32_3mean[order(smws32_3mean$Date),]

#Filter Soil Moisture Datasets

smws32_1mean  <- smws32_1mean[smws32_1mean$smois30A>'0',]
smws32_3mean  <- smws32_3mean[smws32_3mean$smois30A<='0.45',]
smws32_3mean  <- smws32_3mean[smws32_3mean$Date<='2018-05-15',]


plot(smws32_1mean$Group.1,smws32_1mean$smois30A, type = "l", main = "Soil Moisture 30cm Site 1", xlab = "Date", ylab = "Soil Moisture 30A")
plot(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", col = "blue", main = "Soil Moisture 30cm Site 2", xlab = "Date", ylab = "Soil Moisture 30A")
plot(smws32_3mean$Group.1,smws32_3mean$smois30A, type = "l", col = "red", main = "Soil Moisture 30cm Site 3", xlab = "Date", ylab = "Soil Moisture 30A")


{plot(smws32_1mean$Group.1,smws32_1mean$smois30A, type = "l", col = "red", ylim = c(0,0.4), xlab = "Date", ylab = "Soil Moisture", main = "Observed Soil Moisture WS32 30cm")
lines(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", col = "blue", ylim = c(0,0.4))
lines(smws32_3mean$Group.1,smws32_3mean$smois30A, type = "l", col = "black", ylim = c(0,0.4))
legend("topright",inset = 0.05, legend=c("SM1","SM2","SM3"), col=c("red","blue","black"), lty=1)}


smws32_1mean  <- smws32_1mean[smws32_1mean$Date>='2017-01-01',]
smws32_2mean  <- smws32_2mean[smws32_2mean$Date>='2017-01-01',]
smws32_3mean  <- smws32_3mean[smws32_3mean$Date>='2017-01-01',]

smws32_1mean  <- smws32_1mean[smws32_1mean$Date<='2018-05-15',]
smws32_2mean  <- smws32_2mean[smws32_2mean$Date<='2018-05-15',]
smws32_3mean  <- smws32_3mean[smws32_3mean$Date<='2018-05-15',]

{plot(smws32_1mean$Group.1,smws32_1mean$smois30A, type = "l", col = "red", ylim = c(0,0.4), xlab = "Date", ylab = "Soil Moisture", main = "Truncated Observed Soil Moisture WS32 30cm")
lines(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", col = "blue", ylim = c(0,0.4))
lines(smws32_3mean$Group.1,smws32_3mean$smois30A, type = "l", col = "black", ylim = c(0,0.4))
legend("topright",inset = 0.05, legend=c("SM1","SM2","SM3"), col=c("red","blue","black"), lty=1)}


{plot(density(smws32_1mean$smois30A), ylim = c(0,14), xlim = c(0,0.35), col = 'red', main = "Density of Observed Soil Moisture WS32 30cm")
lines(density(smws32_2mean$smois30A), col = 'blue')
lines(density(smws32_3mean$smois30A), col = 'black')
legend("topright",inset = 0.05, legend=c("SM1","SM2","SM3"), col=c("red","blue","black"), lty=1)}


{plot(smws32_1mean$Group.1,smws32_1mean$smois30A, type = "l", col = "red", ylim = c(0,0.4), xlab = "Date", ylab = "Soil Moisture", main = "Truncated Observed Soil Moisture WS32 Station 1")
lines(smws32_1mean$Group.1,smws32_1mean$smois30B, type = "l", col = "orange", ylim = c(0,0.4))
lines(smws32_1mean$Group.1,smws32_1mean$smois60A, type = "l", col = "blue", ylim = c(0,0.4))
lines(smws32_1mean$Group.1,smws32_1mean$smois60B, type = "l", col = "black", ylim = c(0,0.4))
legend("topright",inset = 0.05, legend=c("SM1-30A","SM1-30B","SM1-60A","SM1-60B"), col=c("red","orange","blue","black"), lty=1)}


{plot(density(smws32_1mean$smois30A), ylim = c(0,14), xlim = c(0,0.35), col = 'red', main = "Density of Observed Soil Moisture WS32 Station 1")
lines(density(smws32_1mean$smois30B), col = 'orange')
lines(density(smws32_1mean$smois60A), col = 'blue')
lines(density(smws32_1mean$smois60B), col = 'black')
legend("topright",inset = 0.05, legend=c("SM1-30A","SM1-30B","SM1-60A","SM1-60B"), col=c("red","orange","blue","black"), lty=1)}


{plot(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", col = "red", ylim = c(0,0.4), xlab = "Date", ylab = "Soil Moisture", main = "Truncated Observed Soil Moisture WS32 Station 2")
lines(smws32_2mean$Group.1,smws32_2mean$smois30B, type = "l", col = "orange", ylim = c(0,0.4))
lines(smws32_2mean$Group.1,smws32_2mean$smois60A, type = "l", col = "blue", ylim = c(0,0.4))
lines(smws32_2mean$Group.1,smws32_2mean$smois60B, type = "l", col = "black", ylim = c(0,0.4))
legend("topright",inset = 0.05, legend=c("SM2-30A","SM2-30B","SM2-60A","SM2-60B"), col=c("red","orange","blue","black"), lty=1)}

##extra filtering for smws32_60a
smws32_2mean <- smws32_2mean %>%
  mutate(smois60A = replace(smois60A,Date >= "2017-11-26", NA ))

{plot(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", col = "red", ylim = c(0,0.4), xlab = "Date", ylab = "Soil Moisture", main = "Truncated Observed Soil Moisture WS32 Station 2 Filtered")
lines(smws32_2mean$Group.1,smws32_2mean$smois30B, type = "l", col = "orange", ylim = c(0,0.4))
lines(smws32_2mean$Group.1,smws32_2mean$smois60A, type = "l", col = "blue", ylim = c(0,0.4))
lines(smws32_2mean$Group.1,smws32_2mean$smois60B, type = "l", col = "black", ylim = c(0,0.4))
legend("topright",inset = 0.05, legend=c("SM2-30A","SM2-30B","SM2-60A","SM2-60B"), col=c("red","orange","blue","black"), lty=1)}

{plot(smws32_3mean$Group.1,smws32_3mean$smois30A, type = "l", col = "red", ylim = c(0,0.4), xlab = "Date", ylab = "Soil Moisture", main = "Truncated Observed Soil Moisture WS32 Station 3")
lines(smws32_3mean$Group.1,smws32_3mean$smois30B, type = "l", col = "orange", ylim = c(0,0.4))
lines(smws32_3mean$Group.1,smws32_3mean$smois60A, type = "l", col = "blue", ylim = c(0,0.4))
lines(smws32_3mean$Group.1,smws32_3mean$smois60B, type = "l", col = "black", ylim = c(0,0.4))
legend("topright",inset = 0.05, legend=c("SM3-30A","SM3-30B","SM3-60A","SM3-60B"), col=c("red","orange","blue","black"), lty=1)}

soilmoisture30a<- data.frame(smws32_1mean$Date,smws32_1mean$smois30A, smws32_1mean$smois30B,smws32_1mean$smois60A,smws32_1mean$smois60B)
soilmoisture30b<- data.frame(smws32_2mean$Date,smws32_2mean$smois30A, smws32_2mean$smois30B,smws32_2mean$smois60A,smws32_2mean$smois60B)
soilmoisture30c<- data.frame(smws32_3mean$Date,smws32_3mean$smois30A,smws32_3mean$smois30B,smws32_3mean$smois60A,smws32_3mean$smois60B)


merged30a<- merge(soilmoisture30a,soilmoisture30b, by.x = "smws32_1mean.Date", by.y = "smws32_2mean.Date", all = FALSE)

merged30b<- merge(merged30a,soilmoisture30c, by.x = "smws32_1mean.Date", by.y = "smws32_3mean.Date", all = TRUE)

merged30c<- as.data.frame(rowMeans((merged30b[-1]), na.rm= TRUE))


mergedsm<- cbind(merged30b,merged30c)

colnames(mergedsm)<- c("Date","smois30site1a","smois30site1b","smois60site1a","smois60site1b","smois30site2a","smois30site2b","smois60site2a","smois60site2b","smois30site3a","smois30site3b","smois60site3a","smois60site3b","mergedsoilmoisture")

plot(mergedsm$Date, mergedsm$mergedsoilmoisture, type = "l", main = "Average WS32 Soil Moisture", xlab = "Date", ylab = "Merged Soil Moisture All Data")


plot(mergedsm)

## Calculate Calibration/Validation Split based on SM data

# range(mergedsm$Date)

daysofsmdata<- as.numeric(range(mergedsm$Date)[2] - range(mergedsm$Date)[1])

#70/30 split

Caldays<- round(0.7*daysofsmdata)
Valdays<- daysofsmdata-Caldays

Caldates<- as.Date(1)

Caldates[1]<- range(mergedsm$Date)[1]

Caldates[2]<- range(mergedsm$Date)[1]+Caldays

Valdates<- as.Date(1)

Valdates[1]<-  range(Caldates)[2]+1

Valdates[2]<- range(mergedsm$Date)[2]


```

Plot and Filter Observed Streamflow Data

Original Datasets are recorded as Water Year, We convert to calendar year

```{r Read and Prepare observed Streamflow data for WS32}
## import daily flow dataset
obsws32<- read.csv('C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/daily_flow_ws32.csv', header = F) 

# dataset is recorded as water year, here we convert from water year and note that the water year for this landscape begins in November
## calendar year seems to be correct

obsws32$WYR <- as.numeric(obsws32$V1)
obsws32$Month <- as.numeric(obsws32$V2)
obsws32$Day <- as.numeric(obsws32$V3)
obsws32$flow <- as.numeric(obsws32$V4)

obsws32$CalendarYear<- ifelse((obsws32$Month=="12"|obsws32$Month=="11"),obsws32$WYR-1,obsws32$WYR)

obsws32$CalendarDate <- as.Date(with(obsws32,paste(CalendarYear,Month,Day,sep="-")),"%Y-%m-%d") 

##this removal of 0s may be reason for lag, 0s may be purposefully included in dataset
# instead create timeseries of date from start to end of timeseries and then merge
#obsws32<- obsws32[!(obsws32$flow=="0"),]

obsws32 <- drop_na(obsws32)

plot(obsws32$CalendarDate, obsws32$flow, type = "l", ylab = "Observed Discharge mm/d", xlab = "Date", main = "Observed Discharge WS32 Older Dataset")

obsws32_1<- read.csv('C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/daily_flow_ws32_2017.csv', header = T)
obsws32_2<- read.csv('C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/daily_flow_ws32_2018.csv', header = T)
obsws32_3<- read.csv('C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/daily_flow_ws32_2019.csv', header = T)
obsws32_4<- read.csv('C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/daily_flow_ws32_2020.csv', header = T)
obsws32_5<- read.csv('C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/daily_flow_ws32_2021.csv', header = T)

obsws32b<- rbind(obsws32_1,obsws32_2,obsws32_3,obsws32_4,obsws32_5)

obsws32b$CalendarDate <- as.Date(with(obsws32b,paste(year,month,day,sep="-")),"%Y-%m-%d")

plot(obsws32b$CalendarDate,obsws32b$flow, type = "l", xlab = "Date", ylab = "Streamflow", main = "Observed Discharge WS32 Newer Datasets Merged")

dataset1   <- data.frame(Date=obsws32$CalendarDate,flow=obsws32$flow)
dataset2   <- data.frame(Date=obsws32b$CalendarDate,flow=obsws32b$flow)

fullset<- rbind(dataset1,dataset2)

### Streamflow at Coweeta logged as CSM
### conversion from EcohydRology project
## because we are converting from CSM we set watershed area to 1

fullset$discharge_mm<- ConvertFlowUnits(cfs = fullset$flow, WA=1, AREAunits = "mi2")

#{plot(fullset$Date,fullset$flow, type = "l", xlab = "Date", ylab = "Flow", main = "Streamflow WS32")
#lines(fullset$Date,fullset$discharge_mm, col = 'red')}

plot(fullset$Date,fullset$discharge_mm, type = "l", xlab = "Date", ylab = "Discharge mm/d", main = "Observed Discharge WS32 All Datasets Merged")

plot(fullset$Date,fullset$discharge_mm, type = "l", xlab = "Date", ylab = " Log Discharge mm/d", main = "Log of Observed Discharge WS32 All Datasets Merged", log = "y")

fullset$observedstreamflow<- fullset$discharge_mm

write.csv(fullset,"C:/Users/Carlos/Desktop/ORISE/Streamflow Data/CW/Streamflow/Daily Streamflow Watershed 32/Daily Streamflow Watershed 32/ObservedWS32.csv")

obsws32<- fullset

obsws32sm<- merge(obsws32,mergedsm, by = "Date")

#Caldates
#Valdates

obsws32cal <- obsws32[obsws32$Date >= Caldates[1] & obsws32$Date <= Caldates[2], ]
  
obsws32val <- obsws32[obsws32$Date >= Valdates[1] & obsws32$Date <= Valdates[2], ]
  
obsws32smcal <- obsws32sm[obsws32sm$Date >= Caldates[1] & obsws32sm$Date <= Caldates[2], ]

obsws32smval <- obsws32sm[obsws32sm$Date >= Valdates[1] & obsws32sm$Date <= Valdates[2], ]


```

Merge Observed and Simulated Data

```{r Merge Observed and Simulated Datasets}
## merge values instead of subsetting to match up with simulated dates
singleruntest$bd<- merge(singleruntest$bd,obsws32, by.x = "date", by.y = "Date", all = FALSE)

## merge soil moisture values but include all data
singleruntest$data <-merge(singleruntest$bd,obsws32sm, by.x = "date", by.y = "Date", all = TRUE)
```

Plot Observed and Simulated Data, Plot RHESSys Outputs

```{r Plot Observed and Simulated Datasets}
## Plot Hydrograph comparing modeled and observed streamflow
{hydrograph(input=singleruntest$bd, streamflow=singleruntest$bd$observedstreamflow, streamflow2 = singleruntest$bd$streamflow, timeSeries = singleruntest$bd$date, precip = singleruntest$bd$streamflow,
           P.units = "mm", S.units = "mm normalized by basin area", S1.col = 'Blue', S2.col = 'Red')

legend("topleft",inset = .2, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("blue","red"), lty=1:2)}

{plot(singleruntest$data$date,singleruntest$data$observedstreamflow.x, type = "l", xlab = "Date", ylab = "Streamflow", main = "Predicted vs Observed Streamflow")
lines(singleruntest$data$date, singleruntest$data$streamflow, col = 'RED')
legend("topright",inset = 0, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:1)}

{plot(singleruntest$data$date,singleruntest$data$observedstreamflow.x, type = "l", xlab = "Date", ylab = "Streamflow", main = "Predicted vs Observed Log Streamflow", log = "y")
lines(singleruntest$data$date, singleruntest$data$streamflow, col = 'RED')
legend("topright",inset = 0, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:1)}

predictedvsobservedstreamlm<- lm(observedstreamflow~streamflow, data = singleruntest$bd)

{plot(singleruntest$bd$observedstreamflow,singleruntest$bd$streamflow, xlab = "Observed", ylab = "Predicted", main = "Predicted vs Observed Streamflow", xlim = c(0,55), ylim = c(0,55))
abline(a=0, b=1, col = 'RED', lty = 2, lwd = 2)
legend("right",inset = 0.01, legend = paste("R2 =",format(summary(predictedvsobservedstreamlm)$r.squared,digits=3)))}

{plot(singleruntest$data$date,(singleruntest$data$rz_storage/singleruntest$data$rootdepth), type = "l", ylim = c(0,0.35), xlab = "Date", ylab = "RZ_Storage/Rootdepth", main = "Predicted vs Observed Basin Scale Soil Moisture")
lines(singleruntest$data$date, singleruntest$data$mergedsoilmoisture, col = 'RED')
legend("topright",inset = 0, legend=c("Observed Soil Moisture","Predicted Soil Moisture"), col=c("black","red"), lty=1:1)}

predictedvsobservedsoillm<- lm((rz_storage/rootdepth)~mergedsoilmoisture, data = singleruntest$data)

{plot((singleruntest$data$rz_storage/singleruntest$data$rootdepth),singleruntest$data$mergedsoilmoisture, xlab = "Observed", ylab = "Predicted", main = "Predicted vs Observed Basin Scale Soil Moisture", xlim = c(0.05,0.4), ylim = c(0.05,0.4))
abline(a=0, b=1, col = 'RED', lty = 2, lwd = 2)
legend("right",inset = 0.01, legend = paste("R2 =",format(summary(predictedvsobservedsoillm)$r.squared,digits=3)))}

## Plot other model outputs

par(mfrow=c(5,1), mar = c(2,5,4,2))

plot(singleruntest$bd$date,singleruntest$bd$tmin, type = "l", col = 'BLUE', ylim = c(-15,30), ylab = "Temperature", xlab = "Date")
lines(singleruntest$bd$date,singleruntest$bd$tmax, type = "l", col = 'RED')
plot(singleruntest$bd$date,singleruntest$bd$precip, type = "h", ylab = "Precipitation", xlab = "Date")
plot(singleruntest$bd$date,singleruntest$bd$streamflow, type = "l", ylab = "Streamflow", xlab = "Date", col = 'blue')
plot(singleruntest$bd$date,singleruntest$bd$baseflow, type = "l", ylab = "Baseflow", xlab = "Date", col = 'brown')
plot(singleruntest$bd$date,singleruntest$bd$rz_storage, type = "l", ylab = "RZ Storage", xlab = "Date", col = 'dark green')
plot(singleruntest$bd$date,singleruntest$bd$psn ,type = "l", ylab = "PSN", xlab = "Date")
plot(singleruntest$bd$date,singleruntest$bd$et, type = "l", ylab = "Evaoptranspiration", xlab = "Date")
plot(singleruntest$bd$date,singleruntest$bd$pet, type = "l", ylab = "PET", xlab = "Date")
plot(singleruntest$bd$date,singleruntest$bd$gw.Qout, type = "l", ylab = "Q out", xlab = "Date")
plot(singleruntest$bd$date,singleruntest$bd$gw.storage, type = "l", ylab = "GW Storage", xlab = "Date")

par(mfrow=c(1,1))

### will only plot in growth mode , used to check that vegetation is initialized properly ##
plot(singleruntest$bdg$date, singleruntest$bdg$lai, type = "l", main = "LAI", xlab = "Date")
plot(singleruntest$bdg$date, singleruntest$bdg$soilc, type = "l", main = "Soil Carbon", xlab = "Date")


## plot cal/val sets

{plot(singleruntest$data$date,(singleruntest$data$rz_storage/singleruntest$data$rootdepth), type = "l", ylim = c(0,0.35),xlim = c(obsws32smcal$Date[1],obsws32smval$Date[length(obsws32smval$Date)]), xlab = "Date", ylab = "RZ_Storage/Rootdepth", main = "Predicted vs Observed Basin Scale Soil Moisture")
lines(obsws32smcal$Date,obsws32smcal$mergedsoilmoisture, col = "BLUE")
lines(obsws32smval$Date,obsws32smval$mergedsoilmoisture, col = "RED")
legend("topright",inset = 0, legend=c("Predicted Soil Moisture","Observed Calibration Soil Moisture", "Observed Validation Soil Moisture"), col=c("black","blue","red"), lty=c(1,1,1))}

{plot(singleruntest$data$date,singleruntest$data$streamflow, type = "l", xlab = "Date", ylab = "Streamflow", main = "Predicted vs Observed Basin Scale Streamflow",xlim = c(obsws32smcal$Date[1],obsws32smval$Date[length(obsws32smval$Date)]))
lines(obsws32cal$Date,obsws32cal$observedstreamflow, col = "BLUE")
lines(obsws32val$Date,obsws32val$observedstreamflow, col = "RED")
legend("topright",inset = 0, legend=c("Predicted Streamflow","Observed Calibration Streamflow", "Observed Validation Streamflow"), col=c("black","blue","red"), lty=c(1,1,1))}
```

Testing Precip input vs model precip

```{r eval=FALSE, include=FALSE}
str(daymet_data$data)

daymetdate <- as.Date(paste(daymet_data$data$year,daymet_data$data$yday, sep = "-"), format = "%Y - %j")

str(daymetdate)

daymet_data$data$appendeddate<- daymetdate

xlim=  c(as.Date(singleruntest$bd$date[1]),as.Date(singleruntest$bd$date[length(singleruntest$bd$date)]))

plot(daymet_data$data$appendeddate,daymet_data$data$prcp..mm.day., type = 'h')



{plot(singleruntest$bd$date, singleruntest$bd$precip, type = 'h')


lines(daymet_data$data$appendeddate,daymet_data$data$prcp..mm.day., type = 'h', col = 'red')}


## lag likely caused by mismatch in in put precip data and model input precip data

## attempt to remedy this by creating date vector and appending precip values, replace blanks with na or 0


{plot(singleruntest$bd$date, singleruntest$bd$precip, type = 'h')


lines(fulldaymetprecip$Dates,fulldaymetprecip$prcp..mm.day., type = 'h', col = 'red')}


```

Spatial Data Display

```{r Display Spatial Inputs and Simulated Soil Moisture, fig.height=10, fig.width=14}
setwd(system.file("extdata/", package = "RHESSysIOinR"))

# Original input maps have been cropped before processing in R, without cropping the RHESSYs preparation in the R environment will not function properly, below are the input maps used by R
ws32<- raster("grassexport/cwt_ws32/basin_ws32.tif")
patches<- raster("grassexport/cwt_ws32/patch.tif")
acc10<- raster("grassexport/cwt_ws32/acc10.tif")
aspect10<- raster("grassexport/cwt_ws32/aspect10.tif")
#bt1000<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/b.t1000.tif")
dem10<- raster("grassexport/cwt_ws32/dem10.tif")
dem10f<- raster("grassexport/cwt_ws32/dem10f.tif")
dir10<- raster("grassexport/cwt_ws32/dir10.tif")
drain10<- raster("grassexport/cwt_ws32/drain10.tif")
#ht1000<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/h.t1000.tif")
hillslope<- raster("grassexport/cwt_ws32/hillslope.tif")
roads<- brick("grassexport/cwt_ws32/roads.tif")
#shade10<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/shade10.tif")
slope10<- raster("grassexport/cwt_ws32/slope10.tif")
streams<- raster("grassexport/cwt_ws32/streams.tif")
topidx10<- raster("grassexport/cwt_ws32/topidx10_100.tif")
#xmap<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/xmap.tif")
#ymap<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/ymap.tif")

soilstatic<- raster("grassexport/cwt_ws32/ssurgosoil.tif")

reclass_df <- c(0,256,9)
reclass_static <- matrix(reclass_df, ncol = 3, byrow = TRUE)
soilstaticmap<- reclassify(soilstatic, reclass_static)


soilssurgo<- raster("grassexport/cwt_ws32/ssurgosoil.tif")
soildsm<- raster("grassexport/cwt_ws32/dsmsoil.tif")
veg<- raster("grassexport/cwt_ws32/nlcdveg.tif")




plot(ws32, main ="ws32")
plot(patches, main = "patches")
plot(acc10, main = "acc10")
plot(aspect10, main = "aspect10")
#levelplot(bt1000, col.regions = brewer.pal(name='Spectral', n = 11),at=seq(0,6500,1))
#plot(bt1000, main = "bt1000")
plot(dem10, main = "dem10")
plot(dem10f, main = "dem10f")
plot(dir10, main = "dir10")
plot(drain10, main = "drain10")
#plot(ht1000, main = "ht1000")
plot(hillslope, main = "hillslope")
plot(roads, main = "roads")
#plot(shade10, main = "shade10")
plot(slope10, main = "slope10")
plot(streams, main = "streams")
plot(topidx10, main = "topidx10")
#plot(xmap, main = "xmap")
#plot(ymap, main = "ymap")

plot(soilstaticmap, main = "Static Soil Input", zlim = c(0,26))
plot(soilssurgo, main = "SSURGO Soil Input", zlim = c(0,26))
plot(soildsm, main = "RSS Soil Input", zlim = c(0,26))

plot(veg, main = "NLCD Veg Input")



```

New Soil Map Figure

```{r}

## plot 3 rasters with common legend, legend should only be integers shown in rasters




```

Quick map creation for WS7 soil moisture data display

```{r}

ws7demcrop <- crop(resampleddem,x[27,])
ws7demcrop <- mask(ws7demcrop,x[27,])
plot(ws7demcrop)



Observedws7SMLocationsnt <- read_sf("C:/Users/Carlos/Desktop/ORISE/Soil Moisture Data/CW/knb-lter-cwt.1305.19/1305.kml")
Observedws7SMLocations <- st_transform(Observedws7SMLocationsnt, crs(dem10))

Newsoilmoisturelocationsnt<- read_sf(newsmlocations)
Newsoilmoisturelocations<- st_transform(Newsoilmoisturelocationsnt, crs(dem10))

colorramp<- viridis(1028)

{plot(ws7demcrop, col = colorramp, main = "Coweeta Observed Soil Moisture Locations WS32", legend.args=list(text="Elevation(m)", side = 3, line = 2))
points(c(Observedws7SMLocations[[3]][[3]][1],Observedws7SMLocations[[3]][[4]][1],Observedws7SMLocations[[3]][[5]][1]), c(Observedws7SMLocations[[3]][[3]][2],Observedws7SMLocations[[3]][[4]][2],Observedws7SMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)
points(st_coordinates(Newsoilmoisturelocations), pch =21, col = "black", bg = "green", lwd = 1)
legend("topright", legend = c("Legacy","New"), pch = 20, col= c("red","green"), cex = 1.2)
}

```

Show Observed Soil Moisture Locations

```{r Map of Locations of Observed Soil Moisture, fig.height=10, fig.width=10}

ObservedSMLocationsnt <- read_sf("C:/Users/Carlos/Desktop/ORISE/Soil Moisture Data/CW/knb-lter-cwt.1308.19/1308.kml")

ObservedSMLocations <- st_transform(ObservedSMLocationsnt, crs(dem10))


Newsoilmoisturelocationsnt<- read_sf(newsmlocations)

Newsoilmoisturelocations<- st_transform(Newsoilmoisturelocationsnt, crs(dem10))

colorramp<- viridis(1028)

{plot(dem10, col = colorramp, main = "Coweeta Observed Soil Moisture Locations")
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)

}

 {plot(dem10, col = colorramp, main = "Coweeta Observed Soil Moisture Locations WS32", legend.args=list(text="Elevation(m)", side = 3, line = 2))
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)
points(st_coordinates(Newsoilmoisturelocations), pch =21, col = "black", bg = "green", lwd = 1)
legend("topright", legend = c("Legacy","New"), pch = 20, col= c("red","green"), cex = 1.2)
}

ObservedSMLocations$Name[3]
ObservedSMLocations[[3]][[3]]

ObservedSMLocations$Name[4]
ObservedSMLocations[[3]][[4]]

ObservedSMLocations$Name[5]
ObservedSMLocations[[3]][[5]]

matrix(c(ObservedSMLocations$Name[3],ObservedSMLocations$Name[4],ObservedSMLocations$Name[5],ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1],ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), nrow = 3, ncol = 3)

library(mapview)

Coweeta <- st_read(watershedshapefile)

mapview(Coweeta, label = Coweeta$WS, alpha.regions = 0.1, alpha = 1) +
  mapview(ObservedSMLocations[3:5,]) 



par(mfrow=c(1,2),mar=c(2, 3, 2, 5))
 {plot(dem10, col = colorramp, main = "WS32", legend.args=list(text="          Elevation(m)", side = 3, line = 2, cex = 0.8))
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)
points(st_coordinates(Newsoilmoisturelocations), pch =21, col = "black", bg = "green", lwd = 1)
legend("topright", legend = c("Legacy","New"), pch = 20, col= c("red","green"), cex = 1.2)
}

{plot(ws7demcrop, col = colorramp, main = "WS7", legend.args=list(text="          Elevation(m)", side = 3, line = 2, cex = 0.8))
points(c(Observedws7SMLocations[[3]][[3]][1],Observedws7SMLocations[[3]][[4]][1],Observedws7SMLocations[[3]][[5]][1]), c(Observedws7SMLocations[[3]][[3]][2],Observedws7SMLocations[[3]][[4]][2],Observedws7SMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)
points(st_coordinates(Newsoilmoisturelocations), pch =21, col = "black", bg = "green", lwd = 1)
legend("topright", legend = c("Legacy","New"), pch = 20, col= c("red","green"), cex = 1.2)
}
par(mfrow=c(1,1))
```

Display Observed and Simulated Soil Moisture

```{r Display Spatial Outputs and Simulated Soil Moisture, fig.height=10, fig.width=14}
## Extract values for single date
displayday <- singleruntest$pd[which(singleruntest$pd$date=="2018-10-21")]

## reclassify all patches to na and then reclassify to model output values
reclass_all<- c(-2147483648, 2147483647,NA)
reclass_allm<- matrix(reclass_all, ncol = 3, byrow = TRUE)
displaydaypatches<- reclassify(patches,reclass_allm)

displayday$calculatedrzsm <- displayday$rz_storage/displayday$root.depth

reclass_displayday <- cbind(displayday$patchID,displayday$calculatedrzsm)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches<- reclassify(patches,reclass_displayday)

## Plot Spatial Data Output for RZ Storage
#plot(displaydaypatches, xlim = c(280900,282500), ylim = c(4870000,4872000))

{plot(mask(displaydaypatches,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 RZ Soil Moisture Prediction for 1 day", line = -2)
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", cex = 2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}


reclass_displayday <- cbind(displayday$patchID,displayday$root.depth)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches2<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches2,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 root.depth Prediction for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}


reclass_displayday <- cbind(displayday$patchID,displayday$rz_storage)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches3<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches3,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 rz_storage Prediction for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}

reclass_displayday <- cbind(displayday$patchID,displayday$sat_def)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches4<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches4,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 saturation deficit Prediction for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}



reclass_displayday <- cbind(displayday$patchID,displayday$rz_field_capacity/1000)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches5<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches5,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 RZ Field Capacity for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}



## Plot Hydrograph
{hydrograph(input=singleruntest$bd, streamflow=singleruntest$bd$observedstreamflow, streamflow2 = singleruntest$bd$streamflow, timeSeries = singleruntest$bd$date, precip = singleruntest$bd$streamflow,
           P.units = "mm", S.units = "mm normalized by basin area", S1.col = 'Blue', S2.col = 'Red')
legend("topleft",inset = .2, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("blue","red"), lty=1:2)}

### end show patch map

patchnumbers<- raster::extract(patches,matrix(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1],ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), nrow = 3, ncol = 2))


ObserveSoilMoisturePatches <- matrix(c(ObservedSMLocations$Name[3],ObservedSMLocations$Name[4],ObservedSMLocations$Name[5],ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1],ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2],patchnumbers), nrow = 3, ncol = 4)


## Extract values for a single patch, select patch ID
ObserveSoilMoisturePatches[1,4]
displaypatch<- singleruntest$pd[which(singleruntest$pd$patchID==ObserveSoilMoisturePatches[1,4])]
ObserveSoilMoisturePatches[2,4]
displaypatch2<- singleruntest$pd[which(singleruntest$pd$patchID==ObserveSoilMoisturePatches[2,4])]
ObserveSoilMoisturePatches[3,4]
displaypatch3<- singleruntest$pd[which(singleruntest$pd$patchID==ObserveSoilMoisturePatches[3,4])]

plot(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", main = 'CW WS27 More Detailed RZ Storage Patch #147322', ylim = c(0,.4))

{plot(smws32_1mean$Group.1,smws32_1mean$smois30A, type = "l", ylim = c(0,.4), col = 'darkorange', xlim=as.Date(c("2016-10-1","2019-10-1")), main = "CW WS32 More Detailed Soil Moisture vs Patches",
     xlab = "Date", ylab = "Soil Moisture mm")
lines(smws32_2mean$Group.1,smws32_2mean$smois30A,type = "l", col = 'darkred')
lines(smws32_3mean$Group.1,smws32_3mean$smois30A,type = "l", col = 'blue')
lines(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", col = 'red', lty = 2)
lines(displaypatch2$date,(displaypatch2$rz_storage/displaypatch2$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", col = 'green', lty = 2)
lines(displaypatch3$date,(displaypatch3$rz_storage/displaypatch3$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", col = 'black', lty = 2)

legend("bottomleft",inset = .01, legend=c("Observed Patch 1","Predicted Patch 1","Observed Patch 2","Predicted Patch 2","Observed Patch 3","Predicted Patch 3"), col=c("darkorange", "red","darkred","green","blue","black"), lty=c(1,2,1,2,1,2))}

{plot(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", ylim = c(0,0.4), col = 'BLUE', xlim=as.Date(c("2016-10-1","2019-10-1")), main = "CW WS32 More Detailed Soil Moisture vs Patch #154914",
     xlab = "Date", ylab = "Soil Moisture mm")
lines(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", main = 'CW WS27 More Detailed RZ Storage Patch #154914', col = 'red')
legend("bottomleft",inset = .01, legend=c("Observed Soil Moisture","Predicted Soil Moisture"), col=c("blue","red"), lty=1:1)}


#
#obsws32cal <- obsws32[obsws32$Date >= Caldates[1] & obsws32$Date <= Caldates[2], ]
#obsws32val <- obsws32[obsws32$Date >= Valdates[1] & obsws32$Date <= Valdates[2], ]
#obsws32smcal <- obsws32sm[obsws32sm$Date >= Caldates[1] & obsws32sm$Date <= Caldates[2], ]
#obsws32smval <- obsws32sm[obsws32sm$Date >= Valdates[1] & obsws32sm$Date <= Valdates[2], ]

head(obsws32cal)
head(obsws32val)
head(obsws32smcal)
head(obsws32smval)

#subset Validation range based on Val Dates set by available SM data

validationsubset <- singleruntest$bd[singleruntest$bd$date >= Valdates[1] & singleruntest$bd$date <= Valdates[2], ]

## Fit tests for streamflow

NSE(validationsubset$streamflow,validationsubset$observedstreamflow)

NSE(validationsubset$streamflow,validationsubset$observedstreamflow, FUN=log, epsilon = "Pushpalatha2012", na.rm=TRUE)

nse_value <- NSE(log(validationsubset$streamflow + 1), log(validationsubset$observedstreamflow + 1), na.rm = TRUE)


 KGE(validationsubset$streamflow,validationsubset$observedstreamflow)

plot(validationsubset$streamflow~validationsubset$date, type = "l", col = 'red')
lines(validationsubset$observedstreamflow~validationsubset$date)

# Plot Observed and Predicted Streamflow

{plot(validationsubset$date,validationsubset$streamflow, type = 'l', lty = 2, col = 'RED', main = "Streamflow")
lines(validationsubset$date,validationsubset$observedstreamflow, type = 'l', col = 'BLACK')
legend("topright",inset = .1, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:2)}


{plot(singleruntest$bd$date,singleruntest$bd$streamflow, type = 'l', lty = 2, col = 'RED', main = "Streamflow")
lines(singleruntest$bd$date,singleruntest$bd$observedstreamflow, type = 'l', col = 'BLACK')
legend("topright",inset = .1, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:2)}

#Plot Model RZ SM outputs for patch
{plot(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l",ylim = c(0,0.50), ylab = "Root Zone Storage (mm/m) ", xlab = "Date", main = 'Root Zone Display Patch')
lines(displaypatch$date,(displaypatch$rz_field_capacity/displaypatch$root.depth), type = "l", col = "blue")
lines(displaypatch$date,(displaypatch$rz_wilting_point/displaypatch$root.depth), type = "l", col = "red")
legend("bottomleft",inset = .1, legend=c("Predicted RZ Storage","RZ Field Capacity","RZ Wilting Point"), col=c("black","blue","red"), lty=1:1)}

```

Setup RHESSys Calibration, CLHS used to reduce amount of samples processed

The model calibrates over the following parameters.

M - Decay of hydraulic conductivity with depth
K - Hydraulic conductivity at the surface
Sd - soil depth
Mv - Vertical decay of hydraulic conductivity with depth
Kv - Vertical hydraulic conductivity at the surface
GW1 - Saturated to Groundwater Coefficient
GW2 - Groundwater Loss Coefficient


Parameter & Typical Range from RHESSys Wiki

M - .01 - 20
K - 1 - 600
GW1 -  .001 - .3
GW2 -  .01 - .9

" In order to generate an adequate sample across the full range for each parameter, values from .001 - .01, values from .01 - 1, and values over 1 should be generated separately. The m and K parameters are multipliers on the initial values set for m and K (values assigned to the m and K maps)." - Taken from RHESSys Wiki

Additional Calibration Parameters are available natively although they are not as well documented

pa - multiplier to scale the pore size index
po - multiplier to scale the psi air entry 

vseng1 - multiplies specific leaf areas
vseng2 - multiplies the ratio of shaded to sunlit leaf area
vseng3 - Multiplier used only with the Dickenson algorithm of carbon allocation (set with the epc.allocation_flag variable in the vegetation definition file). It changes the allocation of net photosynthate sensitivity based on the current LAI. If not using the Dickenson strategy of carbon allocation (i.e. using Waring or default Constant strategies), set third value to 1.0. (i.e. -vgsen 1.0 2.0 1.0)

```{r RHESSys Calibration Parameter Setup}
setwd(system.file("extdata/", package = "RHESSysIOinR"))
# number of samples for full data space
fs <- 10000
# number of samples to calibrate over, 100 samples take approx 40 mins in base R and 1 hour in rmarkdown
n <- 200
# create data frame
d <- data.frame(
  m = runif(fs, min=0.5, max=5),
  k = runif(fs, min=0.5, max=60),
  soil_dep = runif(fs, min=0.1, max=0.5),
  m_v = runif(fs, min=0.5, max=15),
  k_v = runif(fs, min=0.5, max=15),
  gw1 = runif(fs, min=0.1, max=0.3),
  gw2 = runif(fs, min=0.1, max=0.6),
  pa = runif(fs, min=0.1, max=1.0),
  po = runif(fs, min=1.0, max=2.0),
  vgseng1 = runif(fs, min=0.1, max=2.0),
  vgseng2 = runif(fs, min=0.1, max=2.0),
  vgseng3 = runif(fs, min=0.1, max=2.0))
# marginal distributions, for analysis
m <- melt(d)
bwplot(variable ~ value, data = m, par.settings = tactile.theme(), main = "distribution of calibration parameters before clhs subsetting")
# cLHS subset
s <- clhs(d, size = n, simple = TRUE, use.cpp = TRUE)
# combine full dataset + subset
g <- make.groups(full = d, cLHS = d[s, ])
# create new list
params<- d[s, ]

params[1:5,]

## Quick and dirty way to include "uncalibrated" result to test against, groundwater model still included for now, unsure of what to do with parameters for gw
## params[1,] = c(1,1,1,1,1,0,0)
## did not produce significantly different result

#write param table to specific text file if file does not exist
## if name is not changed then old table is used
# paramtablename = "out/cwparamtable021723.txt" 

####WORKING

### WORKING

### WORKING
getwd()


##
##UNCOMMENT TO WRITE NEW PARAMS
## write.table(params, file = "out/cwparamtable091923.txt")
###

### writes new params table with todays date to a text file
#write.table(params, file = paste("out/cwparamtable",format(Sys.Date(),"%m%d%y"),".txt",sep = ""))

## reads in specific params file, used for keeping input params constant for analysis
## do not rewrite file if it exits

#{if (file.exists("out/cwparamtable102522.txt"))
#   print("text")}


 #params <- read.table(file = "out/cwparamtable102522.txt")
#params <- read.table(file = "out/cwparamtable032823.txt")
params <- read.table(file = "out/cwparamtable091923.txt")

# prepare RHESSys for run
params<- as.data.frame(params)


input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32dsm.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32dsm",
  flowtable = "CWWS32dsm1.flow",
  start = "2013 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32",
  commandline_options = c("-b"))


#commandline_options = c("-b -p 1 128 154914 154914 ")) <- Patch Specific Output
  
## must incorporate single patch output or local patch output for the purposes of calibration
## make sure to run calibration with no modifiers or 1 for everything except gw1 and gw2
## must refine calibration to do multiple steps, first gw1 gw2, then other variables
## multi point calibration and validation

input_tec_data = IOin_tec_std(start = "2015 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = c("defs/lu_undev.def","defs/lu_agriculture.def","defs/lu_raingarden.def","defs/lu_urban.def"),
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")
 
```
 
Run RHESSys n times sequentially

# NO LONGER USED

```{r RHESSys Sequential Calibration, eval=FALSE, include=FALSE}
start_time = Sys.time()

for(i in 1:n) {
 
stdpars<- IOin_std_pars(
  m = params[i,]$m,
  k = params[i,]$k,
  soil_dep= params[i,]$soil_dep,
  m_v = params[i,]$m_v,
  k_v = params[i,]$k_v,
  gw1 = params[i,]$gw1,
  gw2 = params[i,]$gw2,
  pa = params[i,]$pa,
  po = params[i,]$po,
  vgseng1 = params[i,]$vgseng1,
  vgseng2 = params[i,]$vgseng2,
  vgseng3 = params[i,]$vgseng3)

run_rhessys_single(input_rhessys = input_rhessys,
                   hdr_files = input_hdr,
                   tec_data = input_tec_data,
                   std_pars = stdpars,
                   runID = i)} 

end_time = Sys.time()

end_time - start_time

```

Run RHESSys in Parallel using the foreach package, leaving 4 cores available for other tasks

Takes about 1 hour for 100 runs at 10x10m Daily WS32.

# NO LONGER USED

```{r Run RHESSYS in Parallel using foreach, eval=FALSE, include=FALSE}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:n, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = params[i,]$m,
                            k = params[i,]$k,
                            soil_dep= params[i,]$soil_dep,
                            m_v = params[i,]$m_v,
                            k_v = params[i,]$k_v,
                            gw1 = params[i,]$gw1,
                            gw2 = params[i,]$gw2,
                            pa = params[i,]$pa,
                            po = params[i,]$po,
                            vgseng1 = params[i,]$vgseng1,
                            vgseng2 = params[i,]$vgseng2,
                            vgseng3 = params[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

Prepare Static Inputs

```{r Static }
# prepare RHESSys for run
params<- as.data.frame(params)

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32static.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32static",
  flowtable = "CWWS32static1.flow",
  start = "2013 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32static",
  commandline_options = c("-b"))

#commandline_options = c("-b -p 1 128 154914 154914 ")) <- Patch Specific Output
  
## must incorporate single patch output or local patch output for the purposes of calibration
## make sure to run calibration with no modifiers or 1 for everything except gw1 and gw2
## must refine calibration to do multiple steps, first gw1 gw2, then other variables
## multi point calibration and validation

input_tec_data = IOin_tec_std(start = "2015 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = c("defs/lu_undev.def","defs/lu_agriculture.def","defs/lu_raingarden.def","defs/lu_urban.def"),
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")
 
```
# Modify for MCMC
Run RHESSys Calibration with Static Maps

```{r Run RHESSYS in Parallel using foreach Static, eval=FALSE, include=FALSE}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:n, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = params[i,]$m,
                            k = params[i,]$k,
                            soil_dep= params[i,]$soil_dep,
                            m_v = params[i,]$m_v,
                            k_v = params[i,]$k_v,
                            gw1 = params[i,]$gw1,
                            gw2 = params[i,]$gw2,
                            pa = params[i,]$pa,
                            po = params[i,]$po,
                            vgseng1 = params[i,]$vgseng1,
                            vgseng2 = params[i,]$vgseng2,
                            vgseng3 = params[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

Prepare SSURGO Inputs

```{r SSURGO}
# prepare RHESSys for run
params<- as.data.frame(params)

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32ssurgo.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32ssurgo",
  flowtable = "CWWS32ssurgo1.flow",
  start = "2013 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32ssurgo",
  commandline_options = c("-b"))

#commandline_options = c("-b -p 1 128 154914 154914 ")) <- Patch Specific Output
  
## must incorporate single patch output or local patch output for the purposes of calibration
## make sure to run calibration with no modifiers or 1 for everything except gw1 and gw2
## must refine calibration to do multiple steps, first gw1 gw2, then other variables
## multi point calibration and validation

input_tec_data = IOin_tec_std(start = "2015 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = c("defs/lu_undev.def","defs/lu_agriculture.def","defs/lu_raingarden.def","defs/lu_urban.def"),
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")
 
```
# Modify for MCMC
Run RHESSys with SSURGO Maps

```{r Run RHESSYS in Parallel using foreach SSURGO, eval=FALSE, include=FALSE}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:n, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = params[i,]$m,
                            k = params[i,]$k,
                            soil_dep= params[i,]$soil_dep,
                            m_v = params[i,]$m_v,
                            k_v = params[i,]$k_v,
                            gw1 = params[i,]$gw1,
                            gw2 = params[i,]$gw2,
                            pa = params[i,]$pa,
                            po = params[i,]$po,
                            vgseng1 = params[i,]$vgseng1,
                            vgseng2 = params[i,]$vgseng2,
                            vgseng3 = params[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

Prepare DSM Inputs

```{r DSM}
# prepare RHESSys for run
params<- as.data.frame(params)

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32dsm.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32dsm",
  flowtable = "CWWS32dsm1.flow",
  start = "2013 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32dsm",
  commandline_options = c("-b"))

#commandline_options = c("-b -p 1 128 154914 154914 ")) <- Patch Specific Output
  
## must incorporate single patch output or local patch output for the purposes of calibration
## make sure to run calibration with no modifiers or 1 for everything except gw1 and gw2
## must refine calibration to do multiple steps, first gw1 gw2, then other variables
## multi point calibration and validation

input_tec_data = IOin_tec_std(start = "2015 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = c("defs/lu_undev.def","defs/lu_agriculture.def","defs/lu_raingarden.def","defs/lu_urban.def"),
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")
 
```
# Modify for MCMC
Run RHESSys with RSS Maps

```{r Run RHESSYS in Parallel using foreach DSM, include=FALSE}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:n, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = params[i,]$m,
                            k = params[i,]$k,
                            soil_dep= params[i,]$soil_dep,
                            m_v = params[i,]$m_v,
                            k_v = params[i,]$k_v,
                            gw1 = params[i,]$gw1,
                            gw2 = params[i,]$gw2,
                            pa = params[i,]$pa,
                            po = params[i,]$po,
                            vgseng1 = params[i,]$vgseng1,
                            vgseng2 = params[i,]$vgseng2,
                            vgseng3 = params[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

Read in RHESSys Calibration Outputs and Plot

Calibration is performed using GLUE methodology and Nash-Sutcliffe Model Efficiency (NSE), Log-Normal Nash-Sutcliffe Model Efficiency (lnNSE), and Kling-Gupta Efficiency (KGE).

```{r Read in RHESSys Calibration Outputs and Plot, fig.height=9, fig.width=14, paged.print=TRUE}
 
setwd(system.file("extdata/", package = "RHESSysIOinR"))


testoutput<- readin_rhessys_output("out/cwws32_run200")


# Read in RHESSys Calibration runs
for(i in 1:n) { assign(paste0("cwws32_run",i), readin_rhessys_output(paste0("out/cwws32_run",i)))}

#Prepare observed Streamflow data
obsws32$Date<- as.Date(obsws32$Date)

## plot observed data for period of record and calibration/validation periods as defined by SM data
{plot(obsws32$Date,obsws32$discharge_mm, type = 'l', xlim=c(as.Date(input_rhessys$start_date, "%Y%m%d"),as.Date(input_rhessys$end_date, "%Y%m%d")),ylab = "Observed Discharge mm/d", xlab = "Date", main = "Observed Streamflow Discharge for period of time model is run")
abline(v=as.Date(Caldates[1]), col = 'red', lwd = 2, lty = 2)
abline(v=as.Date(Caldates[2]), col = 'red', lwd = 2, lty = 2)
abline(v=as.Date(Valdates[1]), col = 'blue', lwd = 2, lty = 5)
abline(v=as.Date(Valdates[2]), col = 'blue', lwd = 2, lty = 5)
legend("topright",inset = 0.05, legend=c("Calibration","Validation"), col=c("red","blue"), lty=1)}



##merge calibration runs with observed so dates match up, instead of subsetting 
for(i in 1:n) { assign(paste0("simmerge",i), merge(obsws32,eval(parse(text = paste0("cwws32_run",i,"$bd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("calsubset",i),eval(parse(text = paste0("simmerge",i)))[eval(parse(text = paste0("simmerge",i,"$Date"))) >= Caldates[1] & eval(parse(text = paste0("simmerge",i,"$Date"))) <= Caldates[2], ])
  assign(paste0("valsubset",i),eval(parse(text = paste0("simmerge",i)))[eval(parse(text = paste0("simmerge",i,"$Date"))) >= Valdates[1] & eval(parse(text = paste0("simmerge",i,"$Date"))) <= Valdates[2], ])}

for(i in 1:n) { assign(paste0("simmergesm",i), merge(obsws32sm,eval(parse(text = paste0("cwws32_run",i,"$bd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("calsubsetsm",i),eval(parse(text = paste0("simmergesm",i)))[eval(parse(text = paste0("simmergesm",i,"$Date"))) >= Caldates[1] & eval(parse(text = paste0("simmergesm",i,"$Date"))) <= Caldates[2], ])
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("simmergesm",i)))[eval(parse(text = paste0("simmergesm",i,"$Date"))) >= Valdates[1] & eval(parse(text = paste0("simmergesm",i,"$Date"))) <= Valdates[2], ])}

# simmerge1<- merge(obsws32,eval(parse(text = paste0("cwws32_run",i,"$bd"))), by.x = "Date", by.y="date", all = FALSE)
#simmergesm1<- merge(observedsubsetsm,eval(parse(text = paste0("cwws32_run",i,"$bd"))), by.x = "Date", by.y="date", all = FALSE)


#subset observed data to calibration dates
# calsubset <- eval(parse(text = paste0("simmerge",i)))[eval(parse(text = paste0("simmerge",i,"$Date"))) >= Caldates[1] & eval(parse(text = paste0("simmerge",i,"$Date"))) <= Caldates[2], ]

#calsubsetsm <- observedsubsetsm[observedsubsetsm$Date >= Caldates[1] & observedsubsetsm$Date <= Caldates[2], ]
```

Calculate calibration performance metrics

```{r calculate fit values and append them to a list, fig.height=9, fig.width=14, paged.print=TRUE}
setwd(system.file("extdata/", package = "RHESSysIOinR"))

NSElist<- c()
lnNSElist<- c()
KGElist<- c()

smNSElist<- c()
smlnNSElist<- c()
smKGElist<- c()

for(i in 1:n) { assign(paste0("NSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("simmerge",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("simmerge",i,"$observedstreamflow")))) ))
  NSElist[[i]]<- eval(parse(text = paste0("NSEobs",i))) }

for(i in 1:n) {  assign(paste0("lnNSEobs",i), NSE( sim = as.numeric(eval(parse(text = paste0("simmerge",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("simmerge",i,"$observedstreamflow")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
  lnNSElist[[i]]<- eval(parse(text = paste0("lnNSEobs",i))) }

for(i in 1:n) {  assign(paste0("KGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("simmerge",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("simmerge",i,"$observedstreamflow"))))))
  KGElist[[i]]<- eval(parse(text = paste0("KGEobs",i))) }

for(i in 1:n) {  assign(paste0("smNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("simmergesm",i,"$rz_storage","/simmergesm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("simmergesm",i,"$mergedsoilmoisture"))))))
  smNSElist[[i]]<- eval(parse(text = paste0("smNSEobs",i))) }

for(i in 1:n) {  assign(paste0("smlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("simmergesm",i,"$rz_storage","/simmergesm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("simmergesm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
  smlnNSElist[[i]]<- eval(parse(text = paste0("smlnNSEobs",i))) }

for(i in 1:n) {  assign(paste0("smKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("simmergesm",i,"$rz_storage","/simmergesm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("simmergesm",i,"$mergedsoilmoisture"))))))
  smKGElist[[i]]<- eval(parse(text = paste0("smKGEobs",i))) }

## modified for calsubset

calNSElist<- c()
callnNSElist<- c()
calKGElist<- c()

calsmNSElist<- c()
calsmlnNSElist<- c()
calsmKGElist<- c()

for(i in 1:n) { assign(paste0("cNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("calsubset",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("calsubset",i,"$observedstreamflow")))) ))
  calNSElist[[i]]<- eval(parse(text = paste0("cNSEobs",i))) }

for(i in 1:n) {  assign(paste0("clnNSEobs",i), NSE( sim = as.numeric(eval(parse(text = paste0("calsubset",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("calsubset",i,"$observedstreamflow")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
  callnNSElist[[i]]<- eval(parse(text = paste0("clnNSEobs",i))) }

for(i in 1:n) {  assign(paste0("cKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("calsubset",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("calsubset",i,"$observedstreamflow"))))))
  calKGElist[[i]]<- eval(parse(text = paste0("cKGEobs",i))) }

for(i in 1:n) {  assign(paste0("csmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("calsubsetsm",i,"$rz_storage","/calsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("calsubsetsm",i,"$mergedsoilmoisture"))))))
  calsmNSElist[[i]]<- eval(parse(text = paste0("csmNSEobs",i))) }

for(i in 1:n) {  assign(paste0("csmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("calsubsetsm",i,"$rz_storage","/calsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("calsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
  calsmlnNSElist[[i]]<- eval(parse(text = paste0("csmlnNSEobs",i))) }

for(i in 1:n) {  assign(paste0("csmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("calsubsetsm",i,"$rz_storage","/calsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("calsubsetsm",i,"$mergedsoilmoisture"))))))
  calsmKGElist[[i]]<- eval(parse(text = paste0("csmKGEobs",i))) }

## modified for val subset

valNSElist<- c()
vallnNSElist<- c()
valKGElist<- c()

valsmNSElist<- c()
valsmlnNSElist<- c()
valsmKGElist<- c()


for(i in 1:n) { assign(paste0("vNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubset",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("valsubset",i,"$observedstreamflow")))) ))
  valNSElist[[i]]<- eval(parse(text = paste0("vNSEobs",i))) }

for(i in 1:n) {  assign(paste0("vlnNSEobs",i), NSE( sim = as.numeric(eval(parse(text = paste0("valsubset",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("valsubset",i,"$observedstreamflow")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
  vallnNSElist[[i]]<- eval(parse(text = paste0("vlnNSEobs",i))) }

for(i in 1:n) {  assign(paste0("vKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("valsubset",i,"$streamflow")))), obs = as.numeric(eval(parse(text = paste0("valsubset",i,"$observedstreamflow"))))))
  valKGElist[[i]]<- eval(parse(text = paste0("vKGEobs",i))) }

for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:n) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
  valsmKGElist[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }

NSElist[1:5]
KGElist[1:5]
lnNSElist[1:5]

Reduce(max, NSElist)
Reduce(max, lnNSElist)
Reduce(max, KGElist)

Reduce(max, smNSElist)
Reduce(max, smlnNSElist)
Reduce(max, smKGElist)

which(NSElist == Reduce(max, NSElist), arr.ind=TRUE)
which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE)
which(KGElist == Reduce(max, KGElist), arr.ind=TRUE)

which(smNSElist == Reduce(max, smNSElist), arr.ind=TRUE)
which(smlnNSElist == Reduce(max, smlnNSElist), arr.ind=TRUE)
which(smKGElist == Reduce(max, smKGElist), arr.ind=TRUE)

paramtable<- read.table(file = "out/cwparamtable091923.txt")

paramtable[which(NSElist == Reduce(max, NSElist), arr.ind=TRUE),]
paramtable[which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE),]
paramtable[which(KGElist == Reduce(max, KGElist), arr.ind=TRUE),]

paramtable[which(smNSElist == Reduce(max, smNSElist), arr.ind=TRUE),]
paramtable[which(smlnNSElist == Reduce(max, smlnNSElist), arr.ind=TRUE),]
paramtable[which(smKGElist == Reduce(max, smKGElist), arr.ind=TRUE),]

# paramtable[7,]

###plot all data for GLUE

paramtable$run<- seq.int(nrow(paramtable))
paramtable$rowname<- row.names(paramtable)

paramtable$NSE<- NSElist
paramtable$lnNSE<- lnNSElist
paramtable$KGE<- KGElist

paramtable$smNSE<- smNSElist
paramtable$smlnNSE<- smlnNSElist
paramtable$smKGE<- smKGElist

#add in calibration values

paramtable$calNSE<- calNSElist
paramtable$callnNSE<- callnNSElist
paramtable$calKGE<- calKGElist

paramtable$calsmNSE<- calsmNSElist
paramtable$calsmlnNSE<- calsmlnNSElist
paramtable$calsmKGE<- calsmKGElist

#add in validation values
paramtable$valNSE<- valNSElist
paramtable$vallnNSE<- vallnNSElist
paramtable$valKGE<- valKGElist

paramtable$valsmNSE<- valsmNSElist
paramtable$valsmlnNSE<- valsmlnNSElist
paramtable$valsmKGE<- valsmKGElist

paramtable<- as.data.frame(lapply(paramtable,unlist))

write.table(paramtable, file = "out/dsmcalibrationoutput1023.txt")


top100<- paramtable[order(-paramtable$lnNSE),][1:100,]

top100$run

### use values from top 100 run to table of daily streamflow predictions, for each day predict 95% prediction interval and mean then plot
#subset streamflow value for each day - day 1 day 2 etc
#put all values into a table

top100[["run"]]

toppredictions<- data.frame(cwws32_run1$bd$date)

for (i in top100$run){
 # print(i)
  toppredictions[,ncol(toppredictions)+1] <- eval(parse(text=paste0("cwws32_run",i,"$bd$streamflow")))
  colnames(toppredictions)[ncol(toppredictions)] <- paste0("stream",i)
}

head(toppredictions[1:5,])

toppredictions<- toppredictions[,-1]

toppredictions$upper<- 0
toppredictions$mean<- 0
toppredictions$lower<- 0

for (i in 1:nrow(toppredictions)){
 #  print(i)
  upper= CI(as.numeric(toppredictions[i,]),ci=0.95)[1]
  mean= CI(as.numeric(toppredictions[i,]),ci=0.95)[2]
  lower= CI(as.numeric(toppredictions[i,]),ci=0.95)[3]
  
  toppredictions[i,]$upper<- upper
  toppredictions[i,]$mean<- mean
  toppredictions[i,]$lower<- lower
}

toppredictions<-cbind(date = cwws32_run1$bd$date,toppredictions)

head(toppredictions[1:5,])

# toppredictions[1:500,]

ggplot(toppredictions,aes(date,mean,group=1))+
  geom_line(col = 'red')+
  geom_ribbon(aes(ymin=lower, ymax=upper), fill = "blue", alpha=0.3)+
  geom_line(data=calsubset1,aes(x=Date,y=discharge_mm))+
  ylab("Discharge mm")+
  xlab("Date")+
  labs(title = "Top 100 Model Runs vs Measured Streamflow")


par(mfrow=c(1, 1))

{plot(paramtable$m,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - M", main = "M - Decay of hydraulic conductivity with depth")
abline(h=0,lty=2)}
{plot(paramtable$k,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - K", main = "K - Hydraulic conductivity at the surface")
abline(h=0,lty=2)}
{plot(paramtable$soil_dep,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - Sd", main = "Sd - soil depth")
abline(h=0,lty=2)}
{plot(paramtable$m_v,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - Mv", main = "Mv - Vertical decay of hydraulic conductivity with depth")
abline(h=0,lty=2)}
{plot(paramtable$k_v,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - Kv", main = "Kv - Vertical hydraulic conductivity at the surface")
abline(h=0,lty=2)}
{plot(paramtable$gw1,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - GW1", main = "GW1 - Saturated to Groundwater Coefficient")
abline(h=0,lty=2)}
{plot(paramtable$gw2,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - GW2", main = "GW2 - Groundwater Loss Coefficient")
abline(h=0,lty=2)}

{plot(paramtable$pa,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - pa", main = "pa - Pore Size Index Multiplier")
abline(h=0,lty=2)}
{plot(paramtable$po,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - po", main = "po - PSI Air Entry Multiplier")
abline(h=0,lty=2)}
{plot(paramtable$vgseng1,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - vgseng1", main = "vgseng1 - Specific Leaf Area Multiplier")
abline(h=0,lty=2)}
{plot(paramtable$vgseng2,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - vgseng2", main = "vgseng2 - Ratio of Shaded to Sunlit Modifier")
abline(h=0,lty=2)}
{plot(paramtable$vgseng3,paramtable$NSE, pch = 20,ylab="Nash-Sutcliffe model efficiency coefficient", xlab = "Multiplier - vgseng3", main = "vgseng3 - NOT USED")
abline(h=0,lty=2)}




old.par <- par(mfrow=c(3, 7), mar = c(5,4,4,2))

plot(paramtable$m,paramtable$NSE,xlab = "m parameter", pch = 20)
lines(lowess(paramtable$m,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))
plot(paramtable$k,paramtable$NSE,xlab = "lateral ksat parameter", pch = 20)
lines(lowess(paramtable$k,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))
plot(paramtable$soil_dep,paramtable$NSE,xlab = "sdepth parameter", pch = 20)
lines(lowess(paramtable$soil_dep,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))
plot(paramtable$m_v,paramtable$NSE,xlab = "mv parameter", pch = 20)
lines(lowess(paramtable$m_v,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))
plot(paramtable$k_v,paramtable$NSE,xlab = "ksatv parameter", pch = 20)
lines(lowess(paramtable$k_v,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))
plot(paramtable$gw1,paramtable$NSE,xlab = "gw1 parameter", pch = 20)
lines(lowess(paramtable$gw1,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))
plot(paramtable$gw2,paramtable$NSE,xlab = "gw2 parameter", pch = 20)
lines(lowess(paramtable$gw2,paramtable$NSE, f = 0.1),col="red",ylim = c(-1,0.7))


plot(paramtable$m,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "m parameter", pch = 20)
lines(lowess(paramtable$m,paramtable$lnNSE, f = 0.1),col="red")
plot(paramtable$k,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "lateral ksat parameter", pch = 20)
lines(lowess(paramtable$k,paramtable$lnNSE, f = 0.1),col="red")
plot(paramtable$soil_dep,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "sdepth parameter", pch = 20)
lines(lowess(paramtable$soil_dep,paramtable$lnNSE, f = 0.1),col="red")
plot(paramtable$m_v,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "mv parameter", pch = 20)
lines(lowess(paramtable$m_v,paramtable$lnNSE, f = 0.1),col="red")
plot(paramtable$k_v,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "ksatv parameter", pch = 20)
lines(lowess(paramtable$k_v,paramtable$lnNSE, f = 0.1),col="red")
plot(paramtable$gw1,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "gw1 parameter", pch = 20)
lines(lowess(paramtable$gw1,paramtable$lnNSE, f = 0.1),col="red")
plot(paramtable$gw2,paramtable$lnNSE,ylim = c(-1,0.7),xlab = "gw2 parameter", pch = 20)
lines(lowess(paramtable$gw2,paramtable$lnNSE, f = 0.1),col="red")


plot(paramtable$m,paramtable$KGE,ylim = c(-0.25,1),xlab = "m parameter", pch = 20)
lines(lowess(paramtable$m,paramtable$KGE, f = 0.1),col="red")
plot(paramtable$k,paramtable$KGE,ylim = c(-0.25,1),xlab = "lateral ksat parameter", pch = 20)
lines(lowess(paramtable$k,paramtable$KGE, f = 0.1),col="red")
plot(paramtable$soil_dep,paramtable$KGE,ylim = c(-0.25,1),xlab = "sdepth parameter", pch = 20)
lines(lowess(paramtable$soil_dep,paramtable$KGE, f = 0.1),col="red")
plot(paramtable$m_v,paramtable$KGE,ylim = c(-0.25,0.7),xlab = "mv parameter", pch = 20)
lines(lowess(paramtable$m_v,paramtable$KGE, f = 0.1),col="red")
plot(paramtable$k_v,paramtable$KGE,ylim = c(-0.25,0.7),xlab = "ksatv parameter", pch = 20)
lines(lowess(paramtable$k_v,paramtable$KGE, f = 0.1),col="red")
plot(paramtable$gw1,paramtable$KGE,ylim = c(-0.25,0.7),xlab = "gw1 parameter", pch = 20)
lines(lowess(paramtable$gw1,paramtable$KGE, f = 0.1),col="red")
plot(paramtable$gw2,paramtable$KGE,ylim = c(-0.25,0.7),xlab = "gw2 parameter", pch = 20)
lines(lowess(paramtable$gw2,paramtable$KGE, f = 0.1),col="red")

par(old.par)

old.par <- par(mfrow=c(1, 12), mar = c(5,4,4,2))

plot(paramtable$m,paramtable$smKGE,ylim = c(-0.25,1),xlab = "m parameter", pch = 20)
lines(lowess(paramtable$m,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$k,paramtable$smKGE,ylim = c(-0.25,1),xlab = "lateral ksat parameter", pch = 20)
lines(lowess(paramtable$k,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$soil_dep,paramtable$smKGE,ylim = c(-0.25,1),xlab = "sdepth parameter", pch = 20)
lines(lowess(paramtable$soil_dep,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$m_v,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "mv parameter", pch = 20)
lines(lowess(paramtable$m_v,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$k_v,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "ksatv parameter", pch = 20)
lines(lowess(paramtable$k_v,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$gw1,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "gw1 parameter", pch = 20)
lines(lowess(paramtable$gw1,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$gw2,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "gw2 parameter", pch = 20)
lines(lowess(paramtable$gw2,paramtable$smKGE, f = 0.1),col="red")

plot(paramtable$pa,paramtable$smKGE,ylim = c(-0.25,1),xlab = "pore size index", pch = 20)
lines(lowess(paramtable$pa,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$po,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "psi air entry", pch = 20)
lines(lowess(paramtable$po,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$vgseng1,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "vgseng1", pch = 20)
lines(lowess(paramtable$vgseng1,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$vgseng2,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "vgseng2", pch = 20)
lines(lowess(paramtable$vgseng2,paramtable$smKGE, f = 0.1),col="red")
plot(paramtable$vgseng3,paramtable$smKGE,ylim = c(-0.25,0.7),xlab = "vgseng3", pch = 20)
lines(lowess(paramtable$vgseng3,paramtable$smKGE, f = 0.1),col="red")

par(old.par)

### end plot all data for GLUE

paste0("cwws32_run",which(NSElist == Reduce(max, NSElist), arr.ind=TRUE),"$bd$streamflow")
paste0("cwws32_run",which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE),"$bd$streamflow")
paste0("cwws32_run",which(KGElist == Reduce(max, KGElist), arr.ind=TRUE),"$bd$streamflow")


{plot(cwws32_run33$bd$date,cwws32_run33$bd$streamflow, type = "l", col = 'red', main = "Observed Streamflow vs Top Runs", xlab = "Date", ylab = "Streamflow")
lines(cwws32_run65$bd$date,cwws32_run65$bd$streamflow, col = 'blue')
#lines(cwws32_run46$bd$date,cwws32_run46$bd$streamflow, col = 'green')
lines(simmerge1$Date,simmerge1$observedstreamflow, col = 'orange', lwd = 2, lty = 2)}


#{plot(paste("cwws32_run",which(NSElist == Reduce(max, NSElist), arr.ind=TRUE),"$bd$date", sep = ""),paste("cwws32_run",which(NSElist == Reduce(max, NSElist), arr.ind=TRUE),"$bd$streamflow", sep = ""), type = "l", col = 'red', main = "Observed Streamflow vs Top Runs", xlab = "Date", ylab = "Streamflow")
#lines(paste("cwws32_run",which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE),"$bd$date", sep = ""),paste("cwws32_run",which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE),"$bd$streamflow", sep = ""), col = 'blue')
#lines(cwws32_run80$bd$date,cwws32_run80$bd$streamflow, col = 'green')
#lines(paste("cwws32_run",which(KGElist == Reduce(max, KGElist), arr.ind=TRUE),"$bd$date", sep = ""),paste("cwws32_run",which(KGElist == Reduce(max, KGElist), arr.ind=TRUE),"$bd$streamflow", sep = ""), col = 'orange', lwd = 2, lty = 2)
#legend("topleft",inset = 0.05, legend=c("Oberved Discharge","Best NSE","BEST lnNSE","Best KGE"), col=c("orange","red","blue","green"), lty=c(2,1,1,1))}

{plot(cwws32_run24$bd$date,cwws32_run24$bd$streamflow, type = "l", col = 'red', main = "Observed Streamflow vs Top Runs", xlab = "Date", ylab = "Streamflow", ylim = c(0,10))
#lines(cwws32_run47$bd$date,cwws32_run47$bd$streamflow, col = 'blue')
lines(obsws32$Date,obsws32$discharge_mm, col = 'black', lwd = 2, lty = 2)}

```

*** VALIDATION ***

Run Model once for validation, copied from previous code must clean up


Configure RHESSys Inputs/Outputs for a single run.

Use World Statefile created during spin-up. To run model one time at patch scale.

 COMMAND LINE OPTIONS

-b		Basin output option.  Print out response variables for specified basins. 
-c		Canopy stratum output option.  Print out response variables for specified strata. 
-g		Grow option.  Try to read in dynamic bgc input data and output dynamic bgc parameters. 
-h    Hillslope output option.  Print out response variables for specified hillslopes. 
-p		Patch output option.  Print out response variables for specified patches. 
-r		Routing option. Gives name of flow_table to define explicit routing connectivity.  Also trigger use of explicit routing over TOPMODEL approach. 
-c		Stratum output option.  Print out response variables for specified strata. 


patches listed top to bottom

```{r Configure RHESSys Inputs for Validation}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32",
  flowtable = "CWWS321.flow",
  start = "2013 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32",
#  commandline_options = c("-b -g -p"))
 
 commandline_options = c("-b -p"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))
#1 107 141942 136557
#1 107 149478 136557

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2015 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")

## Calibrated Values 

which(NSElist == Reduce(max, NSElist), arr.ind=TRUE)
which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE)
which(KGElist == Reduce(max, KGElist), arr.ind=TRUE)

which(smNSElist == Reduce(max, smNSElist), arr.ind=TRUE)
which(smlnNSElist == Reduce(max, smlnNSElist), arr.ind=TRUE)
which(smKGElist == Reduce(max, smKGElist), arr.ind=TRUE)

paramtable[which(NSElist == Reduce(max, NSElist), arr.ind=TRUE),]
paramtable[which(lnNSElist == Reduce(max, lnNSElist), arr.ind=TRUE),]
paramtable[which(KGElist == Reduce(max, KGElist), arr.ind=TRUE),]

paramtable[which(smNSElist == Reduce(max, smNSElist), arr.ind=TRUE),]
paramtable[which(smlnNSElist == Reduce(max, smlnNSElist), arr.ind=TRUE),]
paramtable[which(smKGElist == Reduce(max, smKGElist), arr.ind=TRUE),]

stdpars<- IOin_std_pars(
            m = 1.581785,
            k = 41.12945,
            soil_dep= 0.1776117,
            m_v = 8.11574,
            k_v = 0.8713272,
            gw1 = 0.2477113,
            gw2 = 0.4291277,
            pa = 0.3913392,
            po = 1.85424,
            vgseng1 = 1.459184,
            vgseng2 = 1.799894,
            vgseng3 = 1.381696)

#change_def_file()
#test<- IOin_def_pars_simple(as.list("soil_shallowloam.def","porosity_decay", "1000", n = 150 ))

```

Run RHESSys once for validation

```{r Run Rhessys Once for Validation, eval=FALSE, include=FALSE}

start_time = Sys.time()
run_rhessys_single(input_rhessys = input_rhessys,
                   hdr_files = input_hdr,
                   tec_data = input_tec_data,
                   std_pars = stdpars,
                   runID = 'validation')
end_time = Sys.time()
end_time - start_time

```

Read RHESSys Single Run Output

```{r Read in RHESSys Validation Output}

getwd()

singlerunvalidation<- readin_rhessys_output("out/cwws32_runvalidation")

plot(singlerunvalidation$bd$streamflow~singlerunvalidation$bd$date, type = "l", main = "Streamflow", xlab = "Date", ylab = "Streamflow", col = 'DarkBlue')

plot(as.Date(singlerunvalidation$bd$date),singlerunvalidation$bd$rz_storage, type = "l", col = 'black', main = "Basin Scale Root Zone Storage",
    xlab = "Date", ylab = "mm")

#basin scale soil moisture
plot(singlerunvalidation$bd$rz_storage/singlerunvalidation$bdg$root_depth~singlerunvalidation$bd$date, type = "l", main = "RZ_Storage/Root_Depth x Date", xlab = "Date", ylab = "rz_Storage/root_depth", col = 'brown')

plot(singlerunvalidation$bd$lai~singlerunvalidation$bd$date, type = "l", main = "LAI", xlab = "Date", ylab = "LAI", col = 'DarkGreen')
plot(singlerunvalidation$bd$pet~singlerunvalidation$bd$date, type = "l", main = "Potential Evapotranspiration", xlab = "Date", ylab = "PET", col = 'DarkBlue')
plot(singlerunvalidation$bd$et~singlerunvalidation$bd$date, type = "l", main = "Evapotranspiration", xlab = "Date", ylab = "ET", col = 'darkslategray')

plot((singlerunvalidation$bd$unsat_stor/singlerunvalidation$bd$sat_def_z)~singlerunvalidation$bd$date, type = "l", main = "unsat_stor/sat_def_z", xlab = "Date", ylab = "vwc", col = 'DarkGreen')


```

Merge Observed and Simulated Data

```{r Merge Observed and Simulated Validation Datasets}
## merge values instead of subsetting to match up with simulated dates
singlerunvalidation$bd<- merge(singlerunvalidation$bd,obsws32, by.x = "date", by.y = "Date", all = FALSE)

## merge soil moisture values but include all data
singlerunvalidation$data <-merge(singlerunvalidation$bd,obsws32sm, by.x = "date", by.y = "Date", all = TRUE)
```

Plot Observed and Simulated Data, Plot RHESSys Outputs

```{r Plot Observed and Simulated Validation Datasets}
## Plot Hydrograph comparing modeled and observed streamflow
{hydrograph(input=singlerunvalidation$bd, streamflow=singlerunvalidation$bd$observedstreamflow, streamflow2 = singlerunvalidation$bd$streamflow, timeSeries = singlerunvalidation$bd$date, precip = singlerunvalidation$bd$streamflow,
           P.units = "mm", S.units = "mm normalized by basin area", S1.col = 'Blue', S2.col = 'Red')

legend("topleft",inset = .2, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("blue","red"), lty=1:2)}

{plot(singlerunvalidation$data$date,singlerunvalidation$data$observedstreamflow.x, type = "l", xlab = "Date", ylab = "Streamflow", main = "Predicted vs Observed Streamflow")
lines(singlerunvalidation$data$date, singlerunvalidation$data$streamflow, col = 'RED')
legend("topright",inset = 0, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:1)}

{plot(singlerunvalidation$data$date,singlerunvalidation$data$observedstreamflow.x, type = "l", xlab = "Date", ylab = "Streamflow", main = "Predicted vs Observed Log Streamflow", log = "y")
lines(singlerunvalidation$data$date, singlerunvalidation$data$streamflow, col = 'RED')
legend("topright",inset = 0, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:1)}

predictedvsobservedstreamlm<- lm(observedstreamflow~streamflow, data = singlerunvalidation$bd)

{plot(singlerunvalidation$bd$observedstreamflow,singlerunvalidation$bd$streamflow, xlab = "Observed", ylab = "Predicted", main = "Predicted vs Observed Streamflow", xlim = c(0,55), ylim = c(0,55))
abline(a=0, b=1, col = 'RED', lty = 2, lwd = 2)
legend("right",inset = 0.01, legend = paste("R2 =",format(summary(predictedvsobservedstreamlm)$r.squared,digits=3)))}

{plot(singlerunvalidation$data$date,(singlerunvalidation$data$rz_storage/singlerunvalidation$data$rootdepth), type = "l", ylim = c(0,0.35), xlab = "Date", ylab = "RZ_Storage/Rootdepth", main = "Predicted vs Observed Basin Scale Soil Moisture")
lines(singlerunvalidation$data$date, singlerunvalidation$data$mergedsoilmoisture, col = 'RED')
legend("topright",inset = 0, legend=c("Observed Soil Moisture","Predicted Soil Moisture"), col=c("black","red"), lty=1:1)}

predictedvsobservedsoillm<- lm((rz_storage/rootdepth)~mergedsoilmoisture, data = singlerunvalidation$data)

{plot((singlerunvalidation$data$rz_storage/singlerunvalidation$data$rootdepth),singlerunvalidation$data$mergedsoilmoisture, xlab = "Observed", ylab = "Predicted", main = "Predicted vs Observed Basin Scale Soil Moisture", xlim = c(0.05,0.4), ylim = c(0.05,0.4))
abline(a=0, b=1, col = 'RED', lty = 2, lwd = 2)
legend("right",inset = 0.01, legend = paste("R2 =",format(summary(predictedvsobservedsoillm)$r.squared,digits=3)))}

## Plot other model outputs

par(mfrow=c(5,1), mar = c(2,5,4,2))

plot(singlerunvalidation$bd$date,singlerunvalidation$bd$tmin, type = "l", col = 'BLUE', ylim = c(-15,30), ylab = "Temperature", xlab = "Date")
lines(singlerunvalidation$bd$date,singlerunvalidation$bd$tmax, type = "l", col = 'RED')
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$precip, type = "h", ylab = "Precipitation", xlab = "Date")
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$streamflow, type = "l", ylab = "Streamflow", xlab = "Date", col = 'blue')
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$baseflow, type = "l", ylab = "Baseflow", xlab = "Date", col = 'brown')
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$rz_storage, type = "l", ylab = "RZ Storage", xlab = "Date", col = 'dark green')
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$psn ,type = "l", ylab = "PSN", xlab = "Date")
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$et, type = "l", ylab = "Evaoptranspiration", xlab = "Date")
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$pet, type = "l", ylab = "PET", xlab = "Date")
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$gw.Qout, type = "l", ylab = "Q out", xlab = "Date")
plot(singlerunvalidation$bd$date,singlerunvalidation$bd$gw.storage, type = "l", ylab = "GW Storage", xlab = "Date")

par(mfrow=c(1,1))

### will only plot in growth mode , used to check that vegetation is initialized properly ##
plot(singlerunvalidation$bdg$date, singlerunvalidation$bdg$lai, type = "l", main = "LAI", xlab = "Date", col = 'dark green')
plot(singlerunvalidation$bdg$date, singlerunvalidation$bdg$soilc, type = "l", main = "Soil Carbon", xlab = "Date", col = 'brown')


## plot cal/val sets

{plot(singlerunvalidation$data$date,(singlerunvalidation$data$rz_storage/singlerunvalidation$data$rootdepth), type = "l", ylim = c(0,0.35), xlab = "Date", ylab = "RZ_Storage/Rootdepth", main = "Predicted vs Observed Basin Scale Soil Moisture")
lines(obsws32smcal$Date,obsws32smcal$mergedsoilmoisture, col = "BLUE")
lines(obsws32smval$Date,obsws32smval$mergedsoilmoisture, col = "RED")
legend("topright",inset = 0, legend=c("Predicted Soil Moisture","Observed Calibration Soil Moisture", "Observed Validation Soil Moisture"), col=c("black","blue","red"), lty=c(1,1,1))}

{plot(singlerunvalidation$data$date,singlerunvalidation$data$streamflow, type = "l", xlab = "Date", ylab = "Streamflow", main = "Predicted vs Observed Basin Scale Streamflow")
lines(obsws32cal$Date,obsws32cal$observedstreamflow, col = "BLUE")
lines(obsws32val$Date,obsws32val$observedstreamflow, col = "RED")
legend("topright",inset = 0, legend=c("Predicted Streamflow","Observed Calibration Streamflow", "Observed Validation Streamflow"), col=c("black","blue","red"), lty=c(1,1,1))}
```

Spatial Data import and display of inputs

```{r Display Spatial Inputs and Simulated Validation Soil Moisture, fig.height=10, fig.width=14}
# Original input maps have been cropped before processing in R, without cropping the RHESSYs preparation in the R environment will not function properly, below are the input maps used by R
ws32<- raster("grassexport/cwt_ws32/basin_ws32.tif")
patches<- raster("grassexport/cwt_ws32/patch.tif")
acc10<- raster("grassexport/cwt_ws32/acc10.tif")
aspect10<- raster("grassexport/cwt_ws32/aspect10.tif")
#bt1000<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/b.t1000.tif")
dem10<- raster("grassexport/cwt_ws32/dem10.tif")
dem10f<- raster("grassexport/cwt_ws32/dem10f.tif")
dir10<- raster("grassexport/cwt_ws32/dir10.tif")
drain10<- raster("grassexport/cwt_ws32/drain10.tif")
#ht1000<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/h.t1000.tif")
hillslope<- raster("grassexport/cwt_ws32/hillslope.tif")
roads<- brick("grassexport/cwt_ws32/roads.tif")
#shade10<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/shade10.tif")
slope10<- raster("grassexport/cwt_ws32/slope10.tif")
streams<- raster("grassexport/cwt_ws32/streams.tif")
topidx10<- raster("grassexport/cwt_ws32/topidx10_100.tif")
#xmap<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/xmap.tif")
#ymap<- raster("C:/Users/Carlos/Documents/R/win-library/4.0/RHESSysIOinR/extdata/rasters/cwt_ws32/ws32/ymap.tif")


plot(ws32, main ="ws32")
plot(patches, main = "patches")
plot(acc10, main = "acc10")
plot(aspect10, main = "aspect10")
#levelplot(bt1000, col.regions = brewer.pal(name='Spectral', n = 11),at=seq(0,6500,1))
#plot(bt1000, main = "bt1000")
plot(dem10, main = "dem10")
plot(dem10f, main = "dem10f")
plot(dir10, main = "dir10")
plot(drain10, main = "drain10")
#plot(ht1000, main = "ht1000")
{plot(hillslope, main = "hillslope")
  points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)}
plot(roads, main = "roads")
#plot(shade10, main = "shade10")
plot(slope10, main = "slope10")
plot(streams, main = "streams")
plot(topidx10, main = "topidx10")
#plot(xmap, main = "xmap")
#plot(ymap, main = "ymap")

```

Show locations of measured soil moisture and soil maps

```{r Display Locations of Observed Soil Moisture, fig.height=10, fig.width=10}

colorramp<- viridis(128)

{plot(dem10, col = colorramp, main = "Coweeta Observed Soil Moisture Locations")
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)}


matrix(c(ObservedSMLocations$Name[3],ObservedSMLocations$Name[4],ObservedSMLocations$Name[5],ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1],ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), nrow = 3, ncol = 3)


{plot(soilstaticmap, col = colorramp, main = "Coweeta Observed Soil Moisture Locations on Static Soil Map")
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)}

{plot(soilssurgo, col = colorramp, main = "Coweeta Observed Soil Moisture Locations on SSURGO Soil Map")
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)}

{plot(soildsm, col = colorramp, main = "Coweeta Observed Soil Moisture Locations on RSS Soil Map")
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", lwd = 1)}





```

Display outputs from model run

```{r Display Spatial Outputs and Simulated Validation Soil Moisture, fig.height=10, fig.width=14}
## Extract values for single date
displayday <- singlerunvalidation$pd[which(singlerunvalidation$pd$date=="2018-03-21")]

## reclassify all patches to na and then reclassify to model output values
reclass_all<- c(-2147483648, 2147483647,NA)
reclass_allm<- matrix(reclass_all, ncol = 3, byrow = TRUE)
displaydaypatches<- reclassify(patches,reclass_allm)

displayday$calculatedrzsm <- displayday$rz_storage/displayday$root.depth

reclass_displayday <- cbind(displayday$patchID,displayday$calculatedrzsm)
reclass_displayday <- as.matrix(reclass_displayday)

displaydaypatches<- reclassify(patches,reclass_displayday)

## Plot Spatial Data Output for RZ Storage
#plot(displaydaypatches, xlim = c(280900,282500), ylim = c(4870000,4872000))

{plot(mask(displaydaypatches,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 RZ Soil Moisture Prediction for 1 day", line = -2)
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", cex = 2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}


reclass_displayday <- cbind(displayday$patchID,displayday$root.depth)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches2<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches2,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 root.depth Prediction for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}


reclass_displayday <- cbind(displayday$patchID,displayday$rz_storage)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches3<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches3,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 rz_storage Prediction for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}

reclass_displayday <- cbind(displayday$patchID,displayday$sat_def)
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches4<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches4,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 Saturation Deficit Prediction for 1 day in mm", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}

reclass_displayday <- cbind(displayday$patchID,(displayday$unsat_stor/displayday$sat_def_z))
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches5<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches5,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600))
title("CW WS32 unsaturated soil moisture vwc Prediction for 1 day", line = -2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}


reclass_displayday <- cbind(displayday$patchID,((displayday$root_zone.S*displayday$potential_rz_store)/displayday$root.depth))
reclass_displayday <- as.matrix(reclass_displayday)
displaydaypatches6<- reclassify(patches,reclass_displayday)

{plot(mask(displaydaypatches6,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600), zlim = c(0,0.50))
title("CW WS32 Rooting Depth VWC Prediction for 1 day", line = -2)
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", cex = 2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}

{plot(mask(displaydaypatches,ws32), xlim = c(275000,276200), ylim = c(3881000,3881600), zlim = c(0,0.50))
title("CW WS32 RZ Soil Moisture Prediction for 1 day", line = -2)
points(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1]), c(ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), pch = 21, col = "black", bg = "red", cex = 2)
scalebar(200, xy=c(275200, 3880800), type='line',divs = "2")}




## Plot Hydrograph
{hydrograph(input=singlerunvalidation$bd, streamflow=singlerunvalidation$bd$observedstreamflow, streamflow2 = singlerunvalidation$bd$streamflow, timeSeries = singlerunvalidation$bd$date, precip = singlerunvalidation$bd$streamflow,
           P.units = "mm", S.units = "mm normalized by basin area", S1.col = 'Blue', S2.col = 'Red')
legend("topleft",inset = .2, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("blue","red"), lty=1:2)}

### end show patch map




patchnumbers<- raster::extract(patches,matrix(c(ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1],ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2]), nrow = 3, ncol = 2))


ObserveSoilMoisturePatches <- matrix(c(ObservedSMLocations$Name[3],ObservedSMLocations$Name[4],ObservedSMLocations$Name[5],ObservedSMLocations[[3]][[3]][1],ObservedSMLocations[[3]][[4]][1],ObservedSMLocations[[3]][[5]][1],ObservedSMLocations[[3]][[3]][2],ObservedSMLocations[[3]][[4]][2],ObservedSMLocations[[3]][[5]][2],patchnumbers), nrow = 3, ncol = 4)


## Extract values for a single patch, select patch ID
ObserveSoilMoisturePatches[1,4]
displaypatch<- singlerunvalidation$pd[which(singlerunvalidation$pd$patchID==ObserveSoilMoisturePatches[1,4])]
ObserveSoilMoisturePatches[2,4]
displaypatch2<- singlerunvalidation$pd[which(singlerunvalidation$pd$patchID==ObserveSoilMoisturePatches[2,4])]
ObserveSoilMoisturePatches[3,4]
displaypatch3<- singlerunvalidation$pd[which(singlerunvalidation$pd$patchID==ObserveSoilMoisturePatches[3,4])]

plot(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", main = 'CW WS27 More Detailed RZ Storage Patch #147322', ylim = c(0,.4))

{plot(smws32_1mean$Group.1,smws32_1mean$smois30A, type = "l", ylim = c(0,.4), col = 'darkorange', xlim=as.Date(c("2016-10-1","2019-10-1")), main = "CW WS32 More Detailed Soil Moisture vs Patches",
     xlab = "Date", ylab = "Soil Moisture mm")
lines(smws32_2mean$Group.1,smws32_2mean$smois30A,type = "l", col = 'darkred')
lines(smws32_3mean$Group.1,smws32_3mean$smois30A,type = "l", col = 'blue')
lines(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", col = 'red', lty = 2)
lines(displaypatch2$date,(displaypatch2$rz_storage/displaypatch2$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", col = 'green', lty = 2)
lines(displaypatch3$date,(displaypatch3$rz_storage/displaypatch3$root.depth), type = "l", xlab = "Date", ylab = "RZ Storage", col = 'black', lty = 2)



# plot(smws32_1mean$smois30A,(displaypatch$rz_storage/displaypatch$root.depth))

legend("bottomleft",inset = .01, legend=c("Observed Patch 1","Predicted Patch 1","Observed Patch 2","Predicted Patch 2","Observed Patch 3","Predicted Patch 3"), col=c("darkorange", "red","darkred","green","blue","black"), lty=c(1,2,1,2,1,2))}

{plot(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", ylim = c(0,0.4), col = 'BLUE', xlim=as.Date(c("2016-10-1","2019-10-1")), main = "CW WS32 More Detailed Soil Moisture vs Patch #154914",
     xlab = "Date", ylab = "Soil Moisture mm")
lines(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l",lwd = 2, xlab = "Date", ylab = "RZ Storage", main = 'CW WS27 More Detailed RZ Storage Patch #154914', col = 'red')
lines(displaypatch$date, ((displaypatch$root_zone.S*displaypatch$potential_rz_store)/displaypatch$root.depth), type = "l", col = "green")
legend("bottomleft",inset = .01, legend=c("Observed Soil Moisture","Predicted Soil Moisture"), col=c("blue","red"), lty=1:1)}


#
#obsws32cal <- obsws32[obsws32$Date >= Caldates[1] & obsws32$Date <= Caldates[2], ]
#obsws32val <- obsws32[obsws32$Date >= Valdates[1] & obsws32$Date <= Valdates[2], ]
#obsws32smcal <- obsws32sm[obsws32sm$Date >= Caldates[1] & obsws32sm$Date <= Caldates[2], ]
#obsws32smval <- obsws32sm[obsws32sm$Date >= Valdates[1] & obsws32sm$Date <= Valdates[2], ]

head(obsws32cal)
head(obsws32val)
head(obsws32smcal)
head(obsws32smval)

#subset Validation range based on Val Dates set by available SM data

validationsubset <- singlerunvalidation$bd[singlerunvalidation$bd$date >= Valdates[1] & singlerunvalidation$bd$date <= Valdates[2], ]

## Fit tests for streamflow

NSE(validationsubset$streamflow,validationsubset$observedstreamflow)

NSE(validationsubset$streamflow,validationsubset$observedstreamflow, FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE)

KGE(validationsubset$streamflow,validationsubset$observedstreamflow)

# Plot Observed and Predicted Streamflow

{plot(validationsubset$date,validationsubset$streamflow, type = 'l', lty = 2, col = 'RED', main = "Validation Subset Observed and Predicted Streamflow")
lines(validationsubset$date,validationsubset$observedstreamflow, type = 'l', col = 'BLACK')
legend("topright",inset = .1, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:2)}


{plot(singlerunvalidation$bd$date,singlerunvalidation$bd$streamflow, type = 'l', lty = 2, col = 'RED', main = "Observed and Predicted Streamflow")
lines(singlerunvalidation$bd$date,singlerunvalidation$bd$observedstreamflow, type = 'l', col = 'BLACK')
legend("topright",inset = .1, legend=c("Observed Streamflow","Predicted Streamflow"), col=c("black","red"), lty=1:2)}

#Plot Model RZ SM outputs for patch
{plot(displaypatch$date,(displaypatch$rz_storage/displaypatch$root.depth), type = "l",ylim = c(0,0.50), ylab = "Root Zone Storage (mm/m) ", xlab = "Date", main = 'Root Zone Display Patch')
lines(displaypatch$date,(displaypatch$rz_field_capacity/displaypatch$root.depth), type = "l", col = "blue")
lines(displaypatch$date,(displaypatch$rz_wilting_point/displaypatch$root.depth), type = "l", col = "red")
legend("bottomleft",inset = .1, legend=c("Predicted RZ Storage","RZ Field Capacity","RZ Wilting Point"), col=c("black","blue","red"), lty=1:1)}


{plot(displaypatch$date,(displaypatch$unsat_stor/displaypatch$sat_def_z), type = "l",ylim = c(0,0.50), ylab = "Root Zone Storage (mm/m) ", xlab = "Date", main = 'Root Zone Display Patch')
legend("bottomleft",inset = .1, legend=c("Predicted RZ Storage","RZ Field Capacity","RZ Wilting Point"), col=c("black","blue","red"), lty=1:1)}


{plot(smws32_2mean$Group.1,smws32_2mean$smois30A, type = "l", ylim = c(0,0.4), col = 'BLUE', xlim=as.Date(c("2016-10-1","2019-10-1")), main = "CW WS32 More Saturated Zone VWC vs Patch #154914",
     xlab = "Date", ylab = "Soil Moisture mm")
lines(displaypatch$date,(displaypatch$unsat_stor/displaypatch$sat_def_z), type = "l", xlab = "Date", ylab = "RZ Storage", main = 'CW WS27 More Detailed RZ Storage Patch #154914', col = 'red')
legend("bottomleft",inset = .01, legend=c("Observed Soil Moisture","Predicted Soil Moisture"), col=c("blue","red"), lty=1:1)}

```

Model Validation

```{r}

Valdates
## for now run top run and record values

paramtable[which(KGElist == Reduce(max, KGElist), arr.ind=TRUE),]

paramtable[which(smKGElist == Reduce(max, smKGElist), arr.ind=TRUE),]


{plot(cwws32_run136$bd$date,cwws32_run136$bd$streamflow, type = "l", col = 'red', main = "Observed Streamflow vs Top KGE Run", xlab = "Date", ylab = "Streamflow")
lines(obsws32$Date,obsws32$discharge_mm, col = 'orange', lwd = 2, lty = 2)}


valsubset <- simmerge136[simmerge136$Date >= Valdates[1] & simmerge136$Date <= Valdates[2], ]

ValKGE<- KGE(sim = valsubset$streamflow, obs = valsubset$observedstreamflow)


valsubsetsm<- simmergesm136[simmergesm136$Date >= Valdates[1] & simmergesm136$Date <= Valdates[2],]

ValsmKGE<- KGE(sim = valsubsetsm$rz_storage/valsubsetsm$rootdepth, obs = valsubsetsm$mergedsoilmoisture)



ValKGE

ValsmKGE
```

Combine calibration outputs

```{r}
getwd()

dsmdist<- read.csv("out/dsmcalibrationoutput1023.txt", sep=" ")
ssurgodist<- read.csv("out/ssurgocalibrationoutput1023.txt", sep = " ")
staticdist<- read.csv("out/staticcalibrationoutput1023.txt", sep = " ")

ssurgodist
dsmdist
staticdist

ssurgodist$treatment<- 'SSURGO'
dsmdist$treatment<- 'RSS'
staticdist$treatment<- 'Static'


combineddist<- rbind(ssurgodist, dsmdist, staticdist)

ggplot(combineddist, aes(calsmKGE, fill = treatment))+ geom_density(alpha=0.3)

ggplot(combineddist, aes(calKGE, fill = treatment))+ geom_density(alpha=0.3)



smKGEplot<- ggplot(combineddist, aes(calsmKGE, y = treatment, fill = treatment))+ geom_boxplot()+ xlab("Soil Moisture KGE - Calibration") +ylab("Soil Map Input")

KGEplot<- ggplot(combineddist, aes(calKGE, y = treatment, fill = treatment))+ geom_boxplot()+ xlab("Streamflow KGE - Calibration")+ylab(NULL)

ggarrange(smKGEplot,KGEplot, common.legend = TRUE, legend = "top")



smKGEplot<- ggplot(combineddist, aes(calsmKGE, y = treatment, fill = treatment))+ geom_boxplot()+ xlab("Soil Moisture KGE - Calibration") +ylab("Soil Map Input")

KGEplot<- ggplot(combineddist, aes(calKGE, y = treatment, fill = treatment))+ geom_boxplot()+ xlab("Streamflow KGE - Calibration")+ylab(NULL)

ggarrange(smKGEplot,KGEplot, common.legend = TRUE, legend = "top")


text <- "Coweeta Watershed 32 Calibration Performance"
# Create a text grob
tgrob <- text_grob(text,size = 16)
# Draw the text
plot_0 <- as_ggplot(tgrob) + theme(plot.margin = margin(0,3,0,12, "cm"))

ggarrange(plot_0,NULL,smKGEplot,KGEplot,
          ncol = 2,nrow = 2,heights = c(1,5), common.legend = TRUE, legend = "none")




smKGEviolinplot<- ggplot(combineddist, aes(calsmKGE, y = treatment, fill = treatment))+ geom_violin()+ xlab("Soil Moisture KGE - Calibration") +ylab("Soil Map Input")

KGEviolinplot<- ggplot(combineddist, aes(calKGE, y = treatment, fill = treatment))+ geom_violin()+ xlab("Streamflow KGE - Calibration")+ylab(NULL)

ggarrange(smKGEviolinplot,KGEviolinplot, common.legend = TRUE, legend = "top")

library(multcompView)
library(datasets)

oneway.test(valsmKGE~treatment, data= combineddist, var.equal = TRUE)

anova<- aov(valsmKGE~treatment, data = combineddist)

summary(anova)

tukey <- TukeyHSD(anova)
print(tukey)

cld <- multcompLetters4(anova,tukey)

print(cld)



```

Run top n model runs for validation

50/50 weighting

validation will only run 2 years before prediction time period

```{r}
combineddist

plot(ssurgodist$calKGE, ssurgodist$calsmKGE, pch = 19, xlab = "Streamflow KGE", ylab = "Soil Moisture KGE")


combineddist$weightedcal<- rowMeans(combineddist[,c("calKGE","calsmKGE")],)


ordereddist <- combineddist[order(-combineddist$weightedcal),]

ordereddist[ordereddist$treatment=="Static",]


topstatic<- ordereddist[ordereddist$treatment=="Static",]
topssurgo<- ordereddist[ordereddist$treatment=="SSURGO",]
toprss<- ordereddist[ordereddist$treatment=="RSS",]

toprss

```

RSS - prepare to run model n times for patch 1 - only for validation time series

```{r}
 setwd(system.file("extdata/", package = "RHESSysIOinR"))

getwd()

validationruns <- 200

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32dsm.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32dsm",
  flowtable = "CWWS32dsm1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valrss1",
commandline_options = c("-b -p 1 110 136557 136557"))



#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

RSS - Run RHESSYs

```{r Run RHESSYS in Parallel using foreach RSS 1}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = toprss[i,]$m,
                            k = toprss[i,]$k,
                            soil_dep= toprss[i,]$soil_dep,
                            m_v = toprss[i,]$m_v,
                            k_v = toprss[i,]$k_v,
                            gw1 = toprss[i,]$gw1,
                            gw2 = toprss[i,]$gw2,
                            pa = toprss[i,]$pa,
                            po = toprss[i,]$po,
                            vgseng1 = toprss[i,]$vgseng1,
                            vgseng2 = toprss[i,]$vgseng2,
                            vgseng3 = toprss[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

RSS - prepare site specific soil moisture datasets, make sure that each patch looks at this

Site 2 at 60cm A was removed from the averaging because of no data

```{r}
#Prepare observed Soil moisture data
obsws32smvalclean<- data.frame(obsws32smval$Date,obsws32smval$mergedsoilmoisture)
names(obsws32smvalclean)<- c('Date','mergedsoilmoisture')

obsws32smvalclean



obsws32smvalclean$Site3<- rowMeans(subset(obsws32smval, select = c(smois30site3a,smois60site3a,smois30site3b,smois60site3b), na.rm = TRUE))
obsws32smvalclean$Site2<- rowMeans(subset(obsws32smval, select = c(smois30site2a,smois30site2b,smois60site2b), na.rm = TRUE))
obsws32smvalclean$Site1<- rowMeans(subset(obsws32smval, select = c(smois30site1a,smois60site1a,smois30site1b,smois60site1b), na.rm = TRUE))



obsws32smvalclean

plot(obsws32smvalclean$Date,obsws32smvalclean$Site3, type = "l", main = "SITE 3 Averaged Sensor Output")

obsws32smvalclean$Site3


{plot(obsws32smvalclean$Date,obsws32smvalclean$mergedsoilmoisture, type = "l", main = "All site averaged sensor output", lty = 3, lwd = 2, ylim = c(0.10,0.35))
lines(obsws32smvalclean$Date,obsws32smvalclean$Site1, col = 'BLUE')
lines(obsws32smvalclean$Date,obsws32smvalclean$Site2, col = 'RED')
lines(obsws32smvalclean$Date,obsws32smvalclean$Site3, col = 'GREEN')}


```
RSS - read 20 runs, create table and append to table for site 1
```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valrss1_run",i), readin_rhessys_output(paste0("out/cwws32valrss1_run",i)))}


plot(cwws32valrss1_run1$pd$date,cwws32valrss1_run1$pd$rz_storage/cwws32valrss1_run1$pd$root.depth, type = "l")





##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valrss1_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


valmergesm1


validationsmNSElistsite1<- c()
validationsmlnNSElistsite1<- c()
validationsmKGElistsite1<- c()


#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site1"))))))
  validationsmKGElistsite1[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite1


paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")

paste0("valmergesm",i,"$rz_storage","/valmergesm",i,"$root.depth")


```
RSS - Explore Site 1
```{r}

'Exploring Site 1 RSS'


cwws32valrss1_run1

{plot(cwws32valrss1_run1$bd$date, (cwws32valrss1_run1$bd$rz_storage/cwws32valrss1_run1$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm1$Date,valmergesm1$Site1, col = 'BLUE', lty = 3)}



{plot(cwws32valrss1_run3$bd$date, (cwws32valrss1_run3$bd$rz_storage/cwws32valrss1_run3$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm3$Date,valmergesm3$Site1, col = 'BLUE', lty = 3)}

paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")

plot((valmergesm3$root_zone.S*valmergesm3$potential_rz_store)/(valmergesm3$root.depth), type = "l")
plot(valmergesm3$Date, (valmergesm3$rz_storage/valmergesm3$root.depth), type = "l")
plot(valmergesm3$Date, valmergesm3$Site1, type = "l")


{plot(cwws32valrss1_run3$pd$date, (cwws32valrss1_run3$pd$rz_storage/cwws32valrss1_run3$pd$root.depth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm3$Date,valmergesm3$Site1, col = 'BLUE', lty = 3)}


{plot(cwws32valrss1_run3$pd$date, ((cwws32valrss1_run3$pd$root_zone.S*cwws32valrss1_run3$pd$potential_rz_store)/cwws32valrss1_run3$pd$root.depth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm3$Date,valmergesm3$Site1, col = 'BLUE', lty = 3)}

paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")


{plot(cwws32valrss1_run3$bd$date, (cwws32valrss1_run3$bd$rz_storage/cwws32valrss1_run3$bd$rootdepth), type = 'l', ylim = c(0.0,0.26))
lines(valmergesm3$Date,valmergesm3$Site1, col = 'BLUE', lty = 3)}

{plot(cwws32valrss1_run43$pd$date, (cwws32valrss1_run43$pd$rz_storage/cwws32valrss1_run43$pd$root.depth), type = 'l', ylim = c(0.0,0.26))
lines(valmergesm43$Date,valmergesm43$Site1, col = 'BLUE', lty = 3)}

{plot(cwws32valrss1_run43$bd$date, (cwws32valrss1_run43$bd$rz_storage/cwws32valrss1_run43$bd$rootdepth), type = 'l', ylim = c(0.0,0.26))
lines(valmergesm1$Date,valmergesm1$Site1, col = 'BLUE', lty = 3)}

```
RSS - prepare to run model n times for patch 2 - only for validation time series
```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32dsm.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32dsm",
  flowtable = "CWWS32dsm1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valrss2",
 commandline_options = c("-b -p 1 108 141942 141942"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

RSS - run model in parallel 

```{r Run RHESSYS in Parallel using foreach RSS 2}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = toprss[i,]$m,
                            k = toprss[i,]$k,
                            soil_dep= toprss[i,]$soil_dep,
                            m_v = toprss[i,]$m_v,
                            k_v = toprss[i,]$k_v,
                            gw1 = toprss[i,]$gw1,
                            gw2 = toprss[i,]$gw2,
                            pa = toprss[i,]$pa,
                            po = toprss[i,]$po,
                            vgseng1 = toprss[i,]$vgseng1,
                            vgseng2 = toprss[i,]$vgseng2,
                            vgseng3 = toprss[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

RSS - read n runs, create table and append to table

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valrss2_run",i), readin_rhessys_output(paste0("out/cwws32valrss2_run",i)))}

##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valrss2_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


valmergesm1


validationsmNSElistsite2<- c()
validationsmlnNSElistsite2<- c()
validationsmKGElistsite2<- c()


#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site2"))))))
  validationsmKGElistsite2[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite2






```
RSS - Explore Site 2
```{r}

'Exploring Site 2 RSS'


cwws32valrss2_run1

{plot(cwws32valrss2_run1$bd$date, (cwws32valrss2_run1$bd$rz_storage/cwws32valrss2_run1$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm1$Date,valmergesm1$Site2, col = 'BLUE', lty = 3)}



{plot(cwws32valrss2_run3$bd$date, (cwws32valrss2_run3$bd$rz_storage/cwws32valrss2_run3$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm3$Date,valmergesm3$Site2, col = 'BLUE', lty = 3)}

paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")

plot((valmergesm3$root_zone.S*valmergesm3$potential_rz_store)/(valmergesm3$root.depth), type = "l")
plot(valmergesm3$Date, (valmergesm3$rz_storage/valmergesm3$root.depth), type = "l")
plot(valmergesm3$Date, valmergesm3$Site2, type = "l")


{plot(cwws32valrss2_run3$pd$date, (cwws32valrss2_run3$pd$rz_storage/cwws32valrss2_run3$pd$root.depth), type = 'l', ylim = c(0.0,0.26))
lines(valmergesm3$Date,valmergesm3$Site2, col = 'BLUE', lty = 3)}


{plot(cwws32valrss2_run3$pd$date, ((cwws32valrss2_run3$pd$root_zone.S*cwws32valrss2_run3$pd$potential_rz_store)/cwws32valrss2_run3$pd$root.depth), type = 'l', ylim = c(0.0,0.26))
lines(valmergesm3$Date,valmergesm3$Site2, col = 'BLUE', lty = 3)}

paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")


{plot(cwws32valrss2_run3$bd$date, (cwws32valrss2_run3$bd$rz_storage/cwws32valrss2_run3$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm3$Date,valmergesm3$Site2, col = 'BLUE', lty = 3)}

{plot(cwws32valrss2_run43$pd$date, (cwws32valrss2_run43$pd$rz_storage/cwws32valrss2_run43$pd$root.depth), type = 'l', ylim = c(0.0,0.26))
lines(valmergesm43$Date,valmergesm43$Site2, col = 'BLUE', lty = 3)}

{plot(cwws32valrss2_run43$bd$date, (cwws32valrss2_run43$bd$rz_storage/cwws32valrss2_run43$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm1$Date,valmergesm1$Site2, col = 'BLUE', lty = 3)}

```

prepare to run model 20 times for patch 3 - only for validation time series

```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32dsm.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32dsm",
  flowtable = "CWWS32dsm1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valrss3",
 commandline_options = c("-b -p 1 108 149478 149478"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

RSS - run model in parallel

```{r Run RHESSYS in Parallel using foreach RSS 3}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = toprss[i,]$m,
                            k = toprss[i,]$k,
                            soil_dep= toprss[i,]$soil_dep,
                            m_v = toprss[i,]$m_v,
                            k_v = toprss[i,]$k_v,
                            gw1 = toprss[i,]$gw1,
                            gw2 = toprss[i,]$gw2,
                            pa = toprss[i,]$pa,
                            po = toprss[i,]$po,
                            vgseng1 = toprss[i,]$vgseng1,
                            vgseng2 = toprss[i,]$vgseng2,
                            vgseng3 = toprss[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

RSS - read n runs, create table and append to table

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valrss3_run",i), readin_rhessys_output(paste0("out/cwws32valrss3_run",i)))}

##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valrss3_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


validationsmNSElistsite3<- c()
validationsmlnNSElistsite3<- c()
validationsmKGElistsite3<- c()

#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site3"))))))
  validationsmKGElistsite3[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite3

valmergesm2

 
```
RSS - Explore Site 3
```{r}

'Exploring Site 3 RSS'


cwws32valrss3_run1

{plot(cwws32valrss3_run1$bd$date, (cwws32valrss3_run1$bd$rz_storage/cwws32valrss3_run1$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm1$Date,valmergesm1$Site3, col = 'BLUE', lty = 3)}



{plot(cwws32valrss3_run3$bd$date, (cwws32valrss3_run3$bd$rz_storage/cwws32valrss3_run3$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm3$Date,valmergesm3$Site3, col = 'BLUE', lty = 3)}

paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")

plot((valmergesm3$root_zone.S*valmergesm3$potential_rz_store)/(valmergesm3$root.depth), type = "l")
plot(valmergesm3$Date, (valmergesm3$rz_storage/valmergesm3$root.depth), type = "l")
plot(valmergesm3$Date, valmergesm3$Site3, type = "l")


{plot(cwws32valrss3_run3$pd$date, (cwws32valrss3_run3$pd$rz_storage/cwws32valrss3_run3$pd$root.depth), type = 'l', ylim = c(0.0,0.45))
lines(valmergesm3$Date,valmergesm3$Site3, col = 'BLUE', lty = 3)}


{plot(cwws32valrss3_run3$pd$date, ((cwws32valrss3_run3$pd$root_zone.S*cwws32valrss3_run3$pd$potential_rz_store)/cwws32valrss3_run3$pd$root.depth), type = 'l', ylim = c(0.0,0.45))
lines(valmergesm3$Date,valmergesm3$Site3, col = 'BLUE', lty = 3)}

## based on landscape position the previous two figures differ, the second figure does not count inundation as "0" VWC

#paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")


{plot(cwws32valrss3_run3$bd$date, (cwws32valrss3_run3$bd$rz_storage/cwws32valrss3_run3$bd$rootdepth), type = 'l', ylim = c(0.0,0.45))
lines(valmergesm3$Date,valmergesm3$Site3, col = 'BLUE', lty = 3)}

{plot(cwws32valrss3_run43$pd$date, (cwws32valrss3_run43$pd$rz_storage/cwws32valrss3_run43$pd$root.depth), type = 'l', ylim = c(0.0,0.35))
lines(valmergesm43$Date,valmergesm43$Site3, col = 'BLUE', lty = 3)}

{plot(cwws32valrss3_run43$bd$date, (cwws32valrss3_run43$bd$rz_storage/cwws32valrss3_run43$bd$rootdepth), type = 'l', ylim = c(0.12,0.26))
lines(valmergesm1$Date,valmergesm1$Site3, col = 'BLUE', lty = 3)}

```


RSS - merge all 3 sites

```{r}

threesitevalidation1<- data.frame(cbind(site1=as.numeric(validationsmKGElistsite1),site2=as.numeric(validationsmKGElistsite2),site3=as.numeric(validationsmKGElistsite3)))


threesitevalidation<-threesitevalidation1

threesitevalidation$allsites<- rowMeans(threesitevalidation1,na.rm=FALSE)

threesitevalidation


boxplot(threesitevalidation1, main = "Boxplot of Patch Specific Soil Moisture KGE - RSS")
boxplot(threesitevalidation, main = "Boxplot of Patch Specific Soil Moisture KGE - RSS")



plot(validationsmKGElistsite1,validationsmKGElistsite3)

write.csv(threesitevalidation,'threesitevalidationrss.csv')


```

STATIC

run model n times for patch 1 - only for validation time series

```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32static.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32static",
  flowtable = "CWWS32static1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valstatic1",
commandline_options = c("-b -p 1 110 136557 136557"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

run static

```{r Run RHESSYS in Parallel using foreach STATIC 1}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = topstatic[i,]$m,
                            k = topstatic[i,]$k,
                            soil_dep= topstatic[i,]$soil_dep,
                            m_v = topstatic[i,]$m_v,
                            k_v = topstatic[i,]$k_v,
                            gw1 = topstatic[i,]$gw1,
                            gw2 = topstatic[i,]$gw2,
                            pa = topstatic[i,]$pa,
                            po = topstatic[i,]$po,
                            vgseng1 = topstatic[i,]$vgseng1,
                            vgseng2 = topstatic[i,]$vgseng2,
                            vgseng3 = topstatic[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

read 20 runs, create table and append to table for patch 1

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valstatic1_run",i), readin_rhessys_output(paste0("out/cwws32valstatic1_run",i)))}


plot(cwws32valstatic1_run1$pd$date,cwws32valstatic1_run1$pd$rz_storage/cwws32valstatic1_run1$pd$root.depth)



##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valstatic1_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


valmergesm1


validationsmNSElistsite1<- c()
validationsmlnNSElistsite1<- c()
validationsmKGElistsite1<- c()


#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site1"))))))
  validationsmKGElistsite1[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite1



```

prepare to run model 20 times for patch 2 - only for validation time series

```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32static.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32static",
  flowtable = "CWWS32static1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valstatic2",
 commandline_options = c("-b -p 1 108 141942 141942"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

run model in parallel 

```{r Run RHESSYS in Parallel using foreach STATIC 2}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = topstatic[i,]$m,
                            k = topstatic[i,]$k,
                            soil_dep= topstatic[i,]$soil_dep,
                            m_v = topstatic[i,]$m_v,
                            k_v = topstatic[i,]$k_v,
                            gw1 = topstatic[i,]$gw1,
                            gw2 = topstatic[i,]$gw2,
                            pa = topstatic[i,]$pa,
                            po = topstatic[i,]$po,
                            vgseng1 = topstatic[i,]$vgseng1,
                            vgseng2 = topstatic[i,]$vgseng2,
                            vgseng3 = topstatic[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

read 20 runs, create table and append to table

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valstatic2_run",i), readin_rhessys_output(paste0("out/cwws32valstatic2_run",i)))}

##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valstatic2_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


valmergesm1


validationsmNSElistsite2<- c()
validationsmlnNSElistsite2<- c()
validationsmKGElistsite2<- c()


#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site2"))))))
  validationsmKGElistsite2[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite2



```

run model 20 times for patch 3 - only for validation time series

```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32static.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32static",
  flowtable = "CWWS32static1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valstatic3",
 commandline_options = c("-b -p 1 108 149478 149478"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

run model in parallel

```{r Run RHESSYS in Parallel using foreach STATIC 3}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = topstatic[i,]$m,
                            k = topstatic[i,]$k,
                            soil_dep= topstatic[i,]$soil_dep,
                            m_v = topstatic[i,]$m_v,
                            k_v = topstatic[i,]$k_v,
                            gw1 = topstatic[i,]$gw1,
                            gw2 = topstatic[i,]$gw2,
                            pa = topstatic[i,]$pa,
                            po = topstatic[i,]$po,
                            vgseng1 = topstatic[i,]$vgseng1,
                            vgseng2 = topstatic[i,]$vgseng2,
                            vgseng3 = topstatic[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

read 20 runs, create table and append to table

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valstatic3_run",i), readin_rhessys_output(paste0("out/cwws32valstatic3_run",i)))}

##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valstatic3_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


validationsmNSElistsite3<- c()
validationsmlnNSElistsite3<- c()
validationsmKGElistsite3<- c()

#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site3"))))))
  validationsmKGElistsite3[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite3

valmergesm2
 
```

merge all 3 sites 

```{r}

threesitevalidation1<- data.frame(cbind(site1=as.numeric(validationsmKGElistsite1),site2=as.numeric(validationsmKGElistsite2),site3=as.numeric(validationsmKGElistsite3)))


threesitevalidation<-threesitevalidation1

threesitevalidation$allsites<- rowMeans(threesitevalidation1,na.rm=FALSE)

threesitevalidation


boxplot(threesitevalidation1, main = "Boxplot of Patch Specific Soil Moisture KGE - Static")
boxplot(threesitevalidation, main = "Boxplot of Patch Specific Soil Moisture KGE - Static")



plot(validationsmKGElistsite1,validationsmKGElistsite3)

write.csv(threesitevalidation,'threesitevalidationstatic.csv')


```

SSURGO

run model 20 times for patch 1 - only for validation time series

```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32ssurgo.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32ssurgo",
  flowtable = "CWWS32ssurgo1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valssurgo",
commandline_options = c("-b -p 1 110 136557 136557"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

run SSURGO

```{r Run RHESSYS in Parallel using foreach SSURGO 1}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = topssurgo[i,]$m,
                            k = topssurgo[i,]$k,
                            soil_dep= topssurgo[i,]$soil_dep,
                            m_v = topssurgo[i,]$m_v,
                            k_v = topssurgo[i,]$k_v,
                            gw1 = topssurgo[i,]$gw1,
                            gw2 = topssurgo[i,]$gw2,
                            pa = topssurgo[i,]$pa,
                            po = topssurgo[i,]$po,
                            vgseng1 = topssurgo[i,]$vgseng1,
                            vgseng2 = topssurgo[i,]$vgseng2,
                            vgseng3 = topssurgo[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

read 20 runs, create table and append to table for site 1

```{r}

setwd(system.file("extdata/", package = "RHESSysIOinR"))



getwd()

validationruns <- 200

# Read in RHESSys Validation runs
for(i in 1:validationruns) {assign(paste0("cwws32valssurgo_run",i), readin_rhessys_output(paste0("out/cwws32valssurgo_run",i)))}

plot(cwws32valssurgo_run1$pd$date,cwws32valssurgo_run1$pd$rz_storage/cwws32valssurgo_run1$pd$root.depth)





##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valssurgo_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


valmergesm1


validationsmNSElistsite1<- c()
validationsmlnNSElistsite1<- c()
validationsmKGElistsite1<- c()


#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site1"))))))
  validationsmKGElistsite1[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite1



```

prepare to run model n times for patch 2 - only for validation time series

```{r}

validationruns <- 200

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32ssurgo.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32ssurgo",
  flowtable = "CWWS32ssurgo1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valssurgo2",
 commandline_options = c("-b -p 1 108 141942 141942"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

run model in parallel 

```{r Run RHESSYS in Parallel using foreach SSURGO 2, eval=FALSE, include=FALSE}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = topssurgo[i,]$m,
                            k = topssurgo[i,]$k,
                            soil_dep= topssurgo[i,]$soil_dep,
                            m_v = topssurgo[i,]$m_v,
                            k_v = topssurgo[i,]$k_v,
                            gw1 = topssurgo[i,]$gw1,
                            gw2 = topssurgo[i,]$gw2,
                            pa = topssurgo[i,]$pa,
                            po = topssurgo[i,]$po,
                            vgseng1 = topssurgo[i,]$vgseng1,
                            vgseng2 = topssurgo[i,]$vgseng2,
                            vgseng3 = topssurgo[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

read 20 runs, create table and append to table for site 2

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valssurgo2_run",i), readin_rhessys_output(paste0("out/cwws32valssurgo2_run",i)))}

##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valssurgo2_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


valmergesm1


validationsmNSElistsite2<- c()
validationsmlnNSElistsite2<- c()
validationsmKGElistsite2<- c()


#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site2"))))))
  validationsmKGElistsite2[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


 validationsmKGElistsite2



```

run model 20 times for patch 3 - only for validation time series

```{r}

input_rhessys = IOin_rhessys_input(
  version = rh_path,
  tec_file = "tecfiles/tec_daily",
  world_file = "CWWS32ssurgo.world.Y2018M10D31H1.state.Y2018M10D31H1.state",
  world_hdr_prefix = "CWWS32ssurgo",
  flowtable = "CWWS32ssurgo1.flow",
  start = "2015 11 1 1",
  end = "2018 11 1 1",
  output_folder = "out",
  output_prefix = "cwws32valssurgo3",
 commandline_options = c("-b -p 1 108 149478 149478"))

#commandline_options = c("-b -g -p 1 110 136557 136557 -p 1 108 141942 141942 -p 1 108 149478 149478"))

## TEC file dictates model output, begin output a year in to allow model SM to stabilize
# do not output_state or worldfile may be overwritten as output is created
input_tec_data = IOin_tec_std(start = "2017 11 1 1",
                              end = "2018 11 1 1",
                              output_state = FALSE)

input_hdr = IOin_hdr(
  basin = "defs/basin.def",
  hillslope = "defs/hillslope.def",
  zone = "defs/zone.def",
  soil = c("defs/soil_clay.def","defs/soil_clayloam.def","defs/soil_loam.def","defs/soil_loamysand.def","defs/soil_rock.def","defs/soil_sand.def","defs/soil_sandyclay.def","defs/soil_sandyclayloam.def","defs/soil_sandyloam.def","defs/soil_silt.def","defs/soil_siltyclay.def","defs/soil_siltyclayloam.def","defs/soil_siltyloam.def","defs/soil_water.def", "defs/soil_shallowloam.def", "defs/soil_shallowsandyclayloam.def", "defs/soil_shallowsandyloam.def"),
  landuse = "defs/lu_undev.def",
  stratum = c("defs/veg_deciduous/veg_deciduous.def","defs/veg_evergreen/veg_evergreen.def","defs/veg_deciduous_BES.def","defs/veg_eucalypt.def","defs/veg_grass.def","defs/veg_lawn_2cm.def","defs/veg_lawn_5cm.def","defs/veg_lawn_10cm.def","defs/veg_nonveg.def"),
  basestations = "clim/cwtws32local.base")


```

run model in parallel

```{r Run RHESSYS in Parallel using foreach SSURGO 3, eval=FALSE, include=FALSE}
n.cores <- parallel::detectCores() - 4  
  
my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
doParallel::registerDoParallel(cl = my.cluster)

start_time = Sys.time()
  
  foreach(i = 1:validationruns, .packages = 'RHESSysIOinR') %dopar% {
    
    stdpars<- IOin_std_pars(m = topssurgo[i,]$m,
                            k = topssurgo[i,]$k,
                            soil_dep= topssurgo[i,]$soil_dep,
                            m_v = topssurgo[i,]$m_v,
                            k_v = topssurgo[i,]$k_v,
                            gw1 = topssurgo[i,]$gw1,
                            gw2 = topssurgo[i,]$gw2,
                            pa = topssurgo[i,]$pa,
                            po = topssurgo[i,]$po,
                            vgseng1 = topssurgo[i,]$vgseng1,
                            vgseng2 = topssurgo[i,]$vgseng2,
                            vgseng3 = topssurgo[i,]$vgseng3)
    
    run_rhessys_single(input_rhessys = input_rhessys,
                       hdr_files = input_hdr,
                       tec_data = input_tec_data,
                       std_pars = stdpars,
                       runID = i)
  } 
  
  end_time = Sys.time()
  end_time - start_time
```

read 20 runs, create table and append to table for site 3

```{r}
# Read in RHESSys Validation runs
for(i in 1:validationruns) { assign(paste0("cwws32valssurgo3_run",i), readin_rhessys_output(paste0("out/cwws32valssurgo3_run",i)))}

##merge calibration runs with observed so dates match up, instead of subsetting 

for(i in 1:validationruns) { assign(paste0("valmergesm",i), merge(obsws32smvalclean,eval(parse(text = paste0("cwws32valssurgo3_run",i,"$pd"))), by.x = "Date", by.y="date", all = FALSE))
  assign(paste0("valsubsetsm",i),eval(parse(text = paste0("valmergesm",i)))[eval(parse(text = paste0("valmergesm",i,"$date"))) >= Valdates[1] & eval(parse(text = paste0("valmergesm",i,"$date"))) <= Valdates[2], ])}


validationsmNSElistsite3<- c()
validationsmlnNSElistsite3<- c()
validationsmKGElistsite3<- c()

#for(i in 1:n) {  assign(paste0("vsmNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture"))))))
#  valsmNSElist[[i]]<- eval(parse(text = paste0("vsmNSEobs",i))) }

#for(i in 1:n) {  assign(paste0("vsmlnNSEobs",i), NSE(sim = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$rz_storage","/valsubsetsm",i,"$rootdepth")))), obs = as.numeric(eval(parse(text = paste0("valsubsetsm",i,"$mergedsoilmoisture")))), FUN = log, epsilon = "Pushpalatha2012", na.rm=TRUE))
#  valsmlnNSElist[[i]]<- eval(parse(text = paste0("vsmlnNSEobs",i))) }

for(i in 1:validationruns) {  assign(paste0("vsmKGEobs",i), KGE(sim = as.numeric(eval(parse(text = paste0("((valmergesm",i,"$root_zone.S","*valmergesm",i,"$potential_rz_store)","/valmergesm",i,"$root.depth)")))), obs = as.numeric(eval(parse(text = paste0("valmergesm",i,"$Site3"))))))
  validationsmKGElistsite3[[i]]<- eval(parse(text = paste0("vsmKGEobs",i))) }


validationsmKGElistsite3

valmergesm2
 
```

merge all 3 sites

```{r}

threesitevalidation1<- data.frame(cbind(site1=as.numeric(validationsmKGElistsite1),site2=as.numeric(validationsmKGElistsite2),site3=as.numeric(validationsmKGElistsite3)))


threesitevalidation<-threesitevalidation1

threesitevalidation$allsites<- rowMeans(threesitevalidation1,na.rm=FALSE)

threesitevalidation


boxplot(threesitevalidation1, main = "Boxplot of Patch Specific Root Zone Soil Moisture KGE - SSURGO")
boxplot(threesitevalidation, main = "Boxplot of Patch Specific Root Zone Soil Moisture KGE - SSURGO")



plot(validationsmKGElistsite1,validationsmKGElistsite3)

write.csv(threesitevalidation,'threesitevalidationssurgo.csv')


```

Group by group
color by site
plot kge on y axis
plot group on x axis

```{r}

ssurgovalidation<- read.csv("threesitevalidationssurgo.csv")
rssvalidation<- read.csv("threesitevalidationrss.csv")
staticvalidation<- read.csv("threesitevalidationstatic.csv")

staticvalidation$group <- 'Static'
rssvalidation$group <- 'RSS'
ssurgovalidation$group<- 'SSURGO'

combinedvalidation <- rbind(staticvalidation, rssvalidation, ssurgovalidation)


combinedvalidationlong1<- data.frame("KGE" = combinedvalidation$site1, "group" = combinedvalidation$group)
combinedvalidationlong2<- data.frame("KGE" = combinedvalidation$site2, "group" = combinedvalidation$group)
combinedvalidationlong3<- data.frame("KGE" = combinedvalidation$site3, "group" = combinedvalidation$group)
combinedvalidationlong4<- data.frame("KGE" = combinedvalidation$allsites, "group" = combinedvalidation$group)


combinedvalidationlong1$site = '1'
combinedvalidationlong2$site = '2'
combinedvalidationlong3$site = '3'
combinedvalidationlong4$site = 'All Sites'




combinedvalidationlong<- rbind(combinedvalidationlong1,combinedvalidationlong2, combinedvalidationlong3, combinedvalidationlong4)

combinedvalidationlong


#Remove NA values so that boxplot will work

validationnona<- subset(combinedvalidationlong,!is.na(combinedvalidationlong$KGE))


threesitevalidationplot <- ggplot(validationnona, aes(group, y = KGE, fill = site))+ geom_boxplot()+ ylab("Soil Moisture KGE - Validation") +xlab("Soil Map Input")+ ggtitle("Patch Specific Soil Moisture KGE For ALL Calibration Runs, NA Excluded")+geom_hline(yintercept=-0.41,linetype=2, col = 'RED')+ scale_y_continuous(breaks=seq(-6,1,1))+ theme_minimal()

threesitevalidationplot


validationnona




```

